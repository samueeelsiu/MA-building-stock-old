<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Massachusetts Building Analysis Dashboard - NSI-Enhanced USA Structures Dataset</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --secondary-gradient: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            --success-gradient: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            --warning-gradient: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            --dark-gradient: linear-gradient(135deg, #30cfd0 0%, #330867 100%);
            --soil-gradient: linear-gradient(135deg, #8B4513 0%, #D2691E 100%);
        }
        
        /* Modern Theme (Default) */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--primary-gradient);
            min-height: 100vh;
            padding: 20px;
            color: #333;
            transition: all 0.3s ease;
        }
        
        /* Professional Theme */
        body.professional-theme {
            background: #f5f5f5;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease;
        }
        
        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 20px;
            box-shadow: 0 25px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            animation: slideIn 0.6s ease;
            transition: all 0.3s ease;
        }
        
        .professional-theme .container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            animation: none;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .header {
            background: var(--primary-gradient);
            color: white;
            padding: 50px 40px;
            text-align: center;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .professional-theme .header {
            background: #2c3e50;
            padding: 30px 40px;
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            animation: pulse 4s ease-in-out infinite;
        }
        
        .professional-theme .header::before {
            display: none;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.1); opacity: 0.3; }
        }
        
        .header h1 {
            font-size: 2.8em;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
            position: relative;
            z-index: 1;
        }
        
        .professional-theme .header h1 {
            font-size: 2.2em;
            text-shadow: none;
            font-weight: 400;
        }
        
        .header p {
            font-size: 1.2em;
            opacity: 0.95;
            position: relative;
            z-index: 1;
        }
        
        .professional-theme .header p {
            font-size: 1em;
            opacity: 0.9;
        }
        
        .dataset-badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 16px;
            border-radius: 20px;
            margin-top: 10px;
            font-size: 0.9em;
            backdrop-filter: blur(10px);
        }
        
        .professional-theme .dataset-badge {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            backdrop-filter: none;
        }
        
        .nav-container {
            background: white;
            padding: 25px 20px;
            border-bottom: 2px solid #f0f0f0;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }
        
        .professional-theme .nav-container {
            padding: 15px 20px;
            border-bottom: 1px solid #ddd;
            box-shadow: none;
        }
        
        .nav-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: center;
        }
        
        .nav-tab {
            padding: 14px 28px;
            background: #f5f5f5;
            border: 2px solid transparent;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 15px;
            font-weight: 600;
            color: #555;
            position: relative;
            overflow: hidden;
        }
        
        .professional-theme .nav-tab {
            padding: 10px 20px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-weight: 500;
        }
        
        .nav-tab::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: var(--primary-gradient);
            transition: left 0.3s ease;
            z-index: -1;
        }
        
        .professional-theme .nav-tab::before {
            display: none;
        }
        
        .nav-tab:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }
        
        .professional-theme .nav-tab:hover {
            transform: none;
            background: #f8f9fa;
            box-shadow: none;
        }
        
        .nav-tab:hover::before {
            left: 0;
        }
        
        .nav-tab:hover {
            color: white;
        }
        
        .professional-theme .nav-tab:hover {
            color: #333;
        }
        
        .nav-tab.active {
            background: var(--primary-gradient);
            color: white;
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }
        
        .professional-theme .nav-tab.active {
            background: #2c3e50;
            color: white;
            box-shadow: none;
            border-color: #2c3e50;
        }
        
        /* Special style for Soil Analysis tab */
        .nav-tab.soil-tab.active {
            background: var(--soil-gradient);
        }
        
        .content {
            padding: 40px;
            min-height: 600px;
        }
        
        .section {
            display: none;
            animation: fadeIn 0.5s ease;
        }
        
        .professional-theme .section {
            animation: none;
        }
        
        .section.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { 
                opacity: 0;
                transform: translateY(20px);
            }
            to { 
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .section-header {
            margin-bottom: 35px;
            padding-bottom: 20px;
            border-bottom: 3px solid #f0f0f0;
            position: relative;
        }
        
        .professional-theme .section-header {
            border-bottom: 2px solid #e0e0e0;
        }
        
        .section-header::after {
            content: '';
            position: absolute;
            bottom: -3px;
            left: 0;
            width: 100px;
            height: 3px;
            background: var(--primary-gradient);
        }
        
        .professional-theme .section-header::after {
            background: #2c3e50;
            height: 2px;
            bottom: -2px;
        }
        
        .section-header h2 {
            color: #333;
            font-size: 2.2em;
            margin-bottom: 12px;
        }
        
        .professional-theme .section-header h2 {
            font-size: 1.8em;
            font-weight: 500;
        }
        
        .section-header p {
            color: #666;
            font-size: 1.15em;
            line-height: 1.6;
        }
        
        .professional-theme .section-header p {
            font-size: 1em;
        }
        
        .controls {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 2px 15px rgba(0, 0, 0, 0.05);
        }
        
        .professional-theme .controls {
            background: #f8f9fa;
            border-radius: 4px;
            padding: 20px;
            box-shadow: none;
            border: 1px solid #dee2e6;
        }
        
        .control-group {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .control-group:last-child {
            margin-bottom: 0;
        }
        
        .control-group label {
            font-weight: 700;
            color: #495057;
            min-width: 120px;
        }
        
        .professional-theme .control-group label {
            font-weight: 600;
        }
        
        .control-group select,
        .control-group input {
            padding: 10px 18px;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            font-size: 15px;
            transition: all 0.3s ease;
            background: white;
            min-width: 150px;
        }
        
        .professional-theme .control-group select,
        .professional-theme .control-group input {
            border: 1px solid #ced4da;
            border-radius: 4px;
            padding: 8px 12px;
        }
        
        .control-group select:focus,
        .control-group input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .professional-theme .control-group select:focus,
        .professional-theme .control-group input:focus {
            border-color: #2c3e50;
            box-shadow: none;
        }
        
        .control-button {
            padding: 12px 28px;
            background: var(--primary-gradient);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 700;
            font-size: 15px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        
        .professional-theme .control-button {
            background: #2c3e50;
            border-radius: 4px;
            padding: 10px 20px;
            font-weight: 600;
            box-shadow: none;
        }
        
        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        
        .professional-theme .control-button:hover {
            transform: none;
            background: #34495e;
            box-shadow: none;
        }
        
        .control-button:active {
            transform: translateY(0);
        }
        
        .toggle-switch {
            display: inline-flex;
            align-items: center;
            gap: 10px;
        }
        
        .toggle-switch input[type="checkbox"] {
            width: 50px;
            height: 26px;
            appearance: none;
            background: #ddd;
            border-radius: 13px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .toggle-switch input[type="checkbox"]:checked {
            background: #667eea;
        }
        
        .professional-theme .toggle-switch input[type="checkbox"]:checked {
            background: #2c3e50;
        }
        
        .toggle-switch input[type="checkbox"]::after {
            content: '';
            position: absolute;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: white;
            top: 2px;
            left: 2px;
            transition: left 0.3s;
        }
        
        .toggle-switch input[type="checkbox"]:checked::after {
            left: 26px;
        }
        
        .chart-container {
            background: white;
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.08);
            transition: transform 0.3s ease;
        }
        
        .professional-theme .chart-container {
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            padding: 25px;
        }
        
        .chart-container:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12);
        }
        
        .professional-theme .chart-container:hover {
            transform: none;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 25px;
            margin-bottom: 35px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            transition: all 0.3s ease;
            color: white;
            position: relative;
            overflow: hidden;
        }
        
        .professional-theme .stat-card {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 25px;
            color: #333;
        }
        
        .stat-card::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.2) 0%, transparent 70%);
            animation: rotate 10s linear infinite;
        }
        
        .professional-theme .stat-card::before {
            display: none;
        }
        
        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .stat-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 12px 30px rgba(102, 126, 234, 0.3);
        }
        
        .professional-theme .stat-card:hover {
            transform: none;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        .stat-card:nth-child(2) {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        
        .professional-theme .stat-card:nth-child(2) {
            background: white;
        }
        
        .stat-card:nth-child(3) {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }
        
        .professional-theme .stat-card:nth-child(3) {
            background: white;
        }
        
        .stat-card:nth-child(4) {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }
        
        .professional-theme .stat-card:nth-child(4) {
            background: white;
        }
        
        /* Soil-specific stat cards */
        .stat-card.soil-card {
            background: var(--soil-gradient);
        }
        
        .professional-theme .stat-card.soil-card {
            background: white;
            border-color: #8B4513;
        }
        
        .stat-value {
            font-size: 3em;
            font-weight: 800;
            margin-bottom: 8px;
            position: relative;
            z-index: 1;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .professional-theme .stat-value {
            font-size: 2.5em;
            font-weight: 600;
            text-shadow: none;
            color: #2c3e50;
        }
        
        .stat-label {
            font-size: 1.1em;
            opacity: 0.95;
            position: relative;
            z-index: 1;
            font-weight: 600;
        }
        
        .professional-theme .stat-label {
            opacity: 1;
            font-weight: 500;
            color: #6c757d;
        }
        
        .info-box {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            padding: 25px;
            border-radius: 15px;
            border-left: 5px solid #2196f3;
            margin-bottom: 25px;
            position: relative;
            overflow: hidden;
        }
        
        .professional-theme .info-box {
            background: #f0f8ff;
            border-radius: 4px;
            border-left: 4px solid #2196f3;
            padding: 20px;
        }
        
        .info-box.soil-info {
            background: linear-gradient(135deg, #f4e4c1 0%, #e8d4a1 100%);
            border-left-color: #8B4513;
        }
        
        .professional-theme .info-box.soil-info {
            background: #faf0e6;
            border-left-color: #8B4513;
        }
        
        .info-box h3 {
            color: #1565c0;
            margin-bottom: 12px;
            font-size: 1.3em;
        }
        
        .info-box.soil-info h3 {
            color: #6B4423;
        }
        
        .professional-theme .info-box h3 {
            font-size: 1.2em;
            font-weight: 600;
        }
        
        .info-box p {
            color: #0d47a1;
            line-height: 1.6;
        }
        
        .info-box.soil-info p {
            color: #5D4E37;
        }
        
        .professional-theme .info-box p {
            color: #333;
        }
        
        .warning-box {
            background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);
            padding: 20px;
            border-radius: 10px;
            border-left: 5px solid #ff9800;
            margin: 20px 0;
        }
        
        .professional-theme .warning-box {
            background: #fff9e6;
            border-radius: 4px;
            border-left: 4px solid #ff9800;
        }
        
        .warning-box h4 {
            color: #e65100;
            margin-bottom: 10px;
        }
        
        .professional-theme .warning-box h4 {
            font-weight: 600;
        }
        
        .warning-box p {
            color: #bf360c;
            line-height: 1.5;
        }
        
        .professional-theme .warning-box p {
            color: #666;
        }
        
        .error-box {
            background: linear-gradient(135deg, #ffebee 0%, #ffcdd2 100%);
            padding: 20px;
            border-radius: 10px;
            border-left: 5px solid #f44336;
            margin: 20px 0;
            display: none;
        }
        
        .professional-theme .error-box {
            background: #ffebee;
            border-radius: 4px;
            border-left: 4px solid #f44336;
        }
        
        .error-box.show {
            display: block;
            animation: shake 0.5s ease;
        }
        
        .professional-theme .error-box.show {
            animation: none;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        @keyframes fadeInBadge {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        .export-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }
        
        .export-button {
            padding: 10px 20px;
            background: var(--dark-gradient);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .professional-theme .export-button {
            background: #34495e;
            border-radius: 4px;
        }
        
        .export-button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        .professional-theme .export-button:hover {
            transform: none;
            background: #2c3e50;
            box-shadow: none;
        }
        
        /* New styles for heatmap tabs */
        .heatmap-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            background: #f5f5f5;
            padding: 5px;
            border-radius: 10px;
        }
        
        .heatmap-tab {
            padding: 10px 20px;
            background: transparent;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            color: #666;
            transition: all 0.3s ease;
        }
        
        .heatmap-tab.active {
            background: white;
            color: #667eea;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .heatmap-tab:hover:not(.active) {
            background: rgba(255, 255, 255, 0.5);
        }
        
        /* Map container styles */
        .map-container {
            background: white;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.08);
            min-height: 600px;
        }
        
        .professional-theme .map-container {
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.8em;
            }
            
            .nav-tabs {
                flex-direction: column;
            }
            
            .nav-tab {
                width: 100%;
                text-align: center;
            }
            
            .content {
                padding: 20px;
            }
            
            .control-group {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .control-group label {
                min-width: auto;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
        }

            .flowchart-container {
                display: flex;
                flex-direction: column;
                gap: 40px;
                font-family: 'Segoe UI', sans-serif;
                padding: 20px;
                background: #f8f9fa;
                border-radius: 8px;
            }

            .flow-stage {
                background: #ffffff;
                border: 1px solid #dee2e6;
                border-radius: 8px;
                padding: 25px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            }

            .stage-title {
                text-align: center;
                font-size: 1.5em;
                color: #343a40;
                margin-bottom: 25px;
                padding-bottom: 10px;
                border-bottom: 2px solid #e9ecef;
            }

            .flow-content {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 15px;
            }

            .flow-inputs {
                display: flex;
                justify-content: center;
                align-items: center;
                gap: 20px;
                width: 100%;
            }

            .flow-box {
                border-radius: 8px;
                padding: 20px;
                text-align: center;
                width: 100%;
                max-width: 320px;
                border: 2px solid;
                box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            }

            .flow-box h4 {
                margin-bottom: 10px;
                font-size: 1.1em;
            }

            .flow-box p {
                margin: 5px 0;
                font-size: 1em;
                color: #495057;
            }

            .flow-box small {
                display: block;
                margin-top: 10px;
                font-style: italic;
                color: #6c757d;
                font-size: 0.85em;
            }

            .data-source.usa-structures { background-color: #eaf1ff; border-color: #667eea; }
            .data-source.nsi { background-color: #f1eaff; border-color: #764ba2; }
            .data-source.soil-survey { background-color: #ffeeee; border-color: #f5576c; }
            .data-source.nsi-enhanced-input { background-color: #e3f2fd; border-color: #4facfe; }

            .result {
                width: 100%;
                max-width: 500px;
            }

            .result.nsi-enhanced { background-color: #e3f2fd; border-color: #4facfe; }
            .result.final-dataset { background-color: #e8f5e9; border-color: #2E7D32; }


            .operation {
                width: 100%;
                max-width: 600px;
                text-align: left;
                background: #fffbe6;
                border: 2px dashed #f9b115;
            }

            .operation ul {
                list-style-type: none;
                padding-left: 0;
            }

            .operation ul li {
                margin-bottom: 8px;
                padding-left: 20px;
                position: relative;
            }

            .operation ul li::before {
                content: '✓';
                position: absolute;
                left: 0;
                color: #28a745;
                font-weight: bold;
            }

   
            #stage1-metrics details { 
            margin-top: 12px;      
            }
            #stage1-metrics details:first-of-type { 
            margin-top: 0;   
            }
            #stage1-metrics summary {
            font-weight: 700;        
            margin-bottom: 6px;         
            }

        
            #stage1-metrics .funnel-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
            }
            @media (min-width: 700px) {
            #stage1-metrics .funnel-grid {
                grid-template-columns: 1fr 1fr;  
            }
            }
            #stage1-metrics .funnel-block em {
            display: block;       
            margin-bottom: 4px;
            font-style: italic;
            }
            #stage1-metrics .span-2 {
            grid-column: 1 / -1;        
            }


            .plus-icon {
                font-size: 2em;
                color: #6c757d;
                font-weight: bold;
            }

            .flow-arrow {
                font-size: 1.8em;
                color: #6c757d;
            }

            .stage-title {
                text-align: center;
                font-size: 1.5em;
                color: #343a40;
                margin-bottom: 25px; 
                padding-bottom: 10px;
                border-bottom: 2px solid #e9ecef;
                cursor: pointer; 
                display: flex; 
                justify-content: center; 
                align-items: center;
                position: relative; 
                padding-right: 40px; 
                transition: color 0.3s ease;
            }

            .stage-title:hover {
                color: #007bff; 
            }

            .collapse-icon {
                position: absolute;
                right: 20px;
                font-size: 0.8em; 
                transition: transform 0.3s ease;
                color: #6c757d;
            }

            .collapsible-content {
                max-height: 0; 
                overflow: hidden;
                transition: max-height 0.5s ease-out, padding 0.5s ease-out; 
                padding: 0 10px; 
            }

            .collapsible-content.active {
                max-height: 5000px; 
                padding: 15px 10px; 
            }


            .stage-title.active .collapse-icon {
                transform: rotate(180deg);
            }

            .map-container {
                background: white;
                padding: 20px;
                border-radius: 15px;
                margin-bottom: 30px;
                box-shadow: 0 5px 20px rgba(0, 0, 0, 0.08);
                min-height: 650px; /* Ensure the map has enough height */
            }

            .professional-theme .map-container {
                border-radius: 4px;
                box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            }
            /* END: New Map Plot CSS */

            .data-source.boston-permits { background-color: #e0f2f1; border-color: #009688; }

            /* CHANGE: allow the Sankey labels/links to overflow outside the container if needed */
            #yearOccSankey,
            #yearOccSankey > div {
            overflow: visible !important;
            }

            /* (Optional) If your parent container clips content, unclip it too */
            .chart-container,
            .card {
            overflow: visible;
            }

  
            #stage1-metrics > details.stage-panel {
            margin-top: 0;              
            }
            #stage1-metrics > details.stage-panel > summary {
            font-weight: 700;
            cursor: pointer;
            margin-bottom: 8px;       
            }

   
            #stage1-metrics details { 
            margin-top: 12px;            
            }
            #stage1-metrics details:first-of-type { 
            margin-top: 0;
            }
            #stage1-metrics summary { 
            font-weight: 700;
            margin-bottom: 6px;
            }



    </style>
</head>
<body class="professional-theme">
    
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
    </div>
    
    <div class="container">
        <div class="header">
            <h1>Massachusetts Building Analysis Dashboard</h1>
            <p>Interactive Visualization of Building Inventory Data with Soil Analysis</p>
            <div class="dataset-badge">NSI-Enhanced USA Structures Dataset</div>
        </div>
        
        <div class="nav-container">
            <div class="nav-tabs">
                <button class="nav-tab active" onclick="showSection('overview')">Overview</button>
                <button class="nav-tab" onclick="showSection('dataAnalysis')">Data Pipelines</button>
                <button class="nav-tab" onclick="showSection('clustering')">Simple Clustering</button>
                <button class="nav-tab" onclick="showSection('temporal')">Temporal</button>
                <button class="nav-tab" onclick="showSection('pre1940')">Pre-1940</button>
                <button class="nav-tab" onclick="showSection('post1940')">Post-1940</button>
                <button class="nav-tab" onclick="showSection('occupancy')">Occupancy Clustering</button>
                <button class="nav-tab" onclick="showSection('materials')">Materials</button>
                <button class="nav-tab soil-tab" onclick="showSection('soilAnalysis')">Soil Analysis</button>
                <button class="nav-tab" onclick="showSection('historicShoreline')">Boston Historic Shoreline</button>
                <button class="nav-tab" onclick="showSection('interactive')">Explorer</button>
                <button class="nav-tab" onclick="showSection('clf')">CLF Analysis</button>
            </div>
        </div>
        
        <div class="content">
            <!-- OVERVIEW SECTION -->
            <div id="overview" class="section active">
                <div class="section-header">
                    <h2>Dashboard Overview</h2>
                    <p>Comprehensive analysis of Massachusetts building inventory from NSI-Enhanced USA Structures Dataset</p>
                </div>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="totalBuildings">Loading...</div>
                        <div class="stat-label">Total Buildings(Cleaned)</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="avgYear">Loading...</div>
                        <div class="stat-label">Average Year Built</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="avgArea">Loading...</div>
                        <div class="stat-label">Avg Area (sqm)</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="numClusters">Loading...</div>
                        <div class="stat-label">Identified Clusters</div>
                    </div>
                </div>
                

                <div class="info-box">
                    <h3>About This Dashboard</h3>
                    <p class="intro-paragraph">  This interactive dashboard analyzes building data from the NSI-Enhanced USA Structures Dataset for Massachusetts. The analysis includes clustering patterns, temporal distributions, material characteristics, and soil properties of buildings across different time periods. All visualizations use color-blind friendly palettes and are fully interactive.
                        Developed during the fall of 2025 by Lang Shao and supervised by Prof. Demi Fang of the <a href="https://structural-futures.org/">Structural Futures Lab</a>. Data visualizations may not be suitable for distribution at this time and should include attribution. If you have any questions, please contact us.
                    </p>
                </div>
                

                <div class="chart-container">
                    <div id="overviewChart"></div>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <label>Filter by Occupancy:</label>
                        <select id="overviewOccFilter" onchange="createOverviewMap()"></select>
                        
                        <label>Filter by Material:</label>
                        <select id="overviewMaterialFilter" onchange="createOverviewMap()"></select>
                        
                        <label>Filter by Foundation:</label>
                        <select id="overviewFoundationFilter" onchange="createOverviewMap()"></select>
                    </div>
                    <div class="control-group">
                        <label>Color Points By:</label>
                        <select id="overviewColorBy" onchange="createOverviewMap()">
                            <option value="OCC_CLS">Occupancy Class</option>
                            <option value="material_type">Material Type</option>
                            <option value="foundation_type">Foundation Type</option>
                        </select>
                    </div>
                </div>

                <div class="map-container">
                    <div id="overviewMapPlot"></div>
                </div>

                <div class="chart-container">
                    <div id="overviewTimelineChart"></div>
                </div>
                


                <!-- MA Building Distribution Sankey -->
                <div class="chart-container">
                    <div class="section-header" style="margin-top: 0; padding-top: 20px; border: none;">
                        <h3 style="color: #2c3e50;">MA Building Hierarchical Distribution</h3>
                        <p style="color: #555;">Multi-level breakdown: Occupancy → Area → Height → Year → Drainage</p>
                    </div>
                    
                    <div class="controls" style="margin-bottom: 20px; background: #f8f9fa; padding: 15px; border-radius: 8px;">
                        <div class="control-group">
                            <label style="font-weight: 600; margin-right: 10px;">Select Occupancy Class:</label>
                            <select id="hierarchicalOccupancy" onchange="createBuildingDistributionSankey()" 
                                    style="padding: 8px 12px; border: 1px solid #dee2e6; border-radius: 4px; font-size: 14px;">
                                <option value="all">All Buildings</option>
                                <option value="Residential">Residential</option>
                                <option value="Commercial">Commercial</option>
                                <option value="Industrial">Industrial</option>
                                <option value="Agriculture">Agriculture</option>
                                <option value="Government">Government</option>
                                <option value="Assembly">Assembly</option>
                                <option value="Education">Education</option>
                                <option value="Utility and Misc">Utility and Misc</option>
                                <option value="Unclassified">Unclassified</option>
                            </select>
                        </div>

                        <div class="control-group">
                            <label style="font-weight: 600; margin-right: 10px;">Sankey Diagram View:</label>
                            <select id="sankeyViewSelector" onchange="createBuildingDistributionSankey()"
                                    style="padding: 8px 12px; border: 1px solid #dee2e6; border-radius: 4px; font-size: 14px;">
                                <option value="by_count" selected>By Building Count</option>
                                <option value="by_gfa">By Total GFA (sqm)</option>
                                <option value="by_count_simplified">By Building Count (Simplified)</option>
                                <option value="by_gfa_simplified">By Total GFA (Simplified)</option>
                            </select>
                        </div>

                    </div>
                    
                    <div id="buildingDistributionSankey"></div>

                    <!-- Year → Occupancy → Material → Foundation → Soil (compname) Sankey -->
                    <div class="chart-container">
                    <div class="section-header" style="margin-top: 0; padding-top: 20px; border: none;">
                        <h3 id="yearOccSankeyTitle" style="color:#2c3e50;">Construction Year → Occupancy → Material → Foundation → Soil</h3>
                        <p style="color:#555;">Base: Year → Occupancy. Toggle columns to the right.</p>

                        <!-- Toggles -->
                        <div style="margin-top:8px;">
                        <label style="margin-right:16px;">
                            <input type="checkbox" id="toggleMaterial" checked onchange="handleYearOccToggleChange()">
                            Show Material
                        </label>
                        <label style="margin-right:16px;">
                            <input type="checkbox" id="toggleFoundation" checked onchange="handleYearOccToggleChange()">
                            Show Foundation
                        </label>
                        <label>
                            <input type="checkbox" id="toggleSoil" checked onchange="handleYearOccToggleChange()">
                            Show Soil (compname)
                        </label>

                        <!-- NEW: metric selector for Year→Occ→... Sankey -->
                        <span style="display:inline-block; margin-left:20px; font-weight:600;">Metric:</span>
                        <select id="yearOccMetric" onchange="createYearOccSankey()"
                                style="padding:6px 10px; border:1px solid #dee2e6; border-radius:4px; font-size:13px;">
                        <option value="count" selected>Buildings count</option>
                        <option value="gfa">GFA (sqm)</option>
                        </select>

                        <!-- Export / Screenshot bar -->
                        <span style="display:inline-block; margin-left:20px; font-weight:600;">Export:</span>

                        <select id="yearOccExportFormat"
                                style="padding:6px 10px; border:1px solid #dee2e6; border-radius:4px; font-size:13px; margin-left:6px;">
                        <option value="png" selected>PNG (raster)</option>
                        <option value="svg">SVG (vector)</option>
                        <option value="jpeg">JPEG</option>
                        <option value="webp">WEBP</option>
                        </select>

                        <select id="yearOccExportScale"
                                title="Scale for PNG/JPEG/WEBP"
                                style="padding:6px 10px; border:1px solid #dee2e6; border-radius:4px; font-size:13px; margin-left:6px;">
                        <option value="1">1×</option>
                        <option value="2">2×</option>
                        <option value="3" selected>3×</option>
                        <option value="4">4×</option>
                        </select>

                        <label style="margin-left:8px; font-weight:500;">
                        <input type="checkbox" id="yearOccTransparentBg"> Transparent BG
                        </label>

                        <button onclick="downloadYearOccSankey()"
                                style="margin-left:8px; padding:6px 10px; border:1px solid #ced4da; border-radius:6px; background:#f8f9fa; cursor:pointer;">
                        Save
                        </button>



                        </div>
                    </div>

                    <!-- The actual Sankey container -->
                    <div id="yearOccSankey"></div>
                    </div>



                </div>

                
                <div class="chart-container">
                    <div class="section-header" style="margin-top: 0; padding-top: 20px; border: none;">
                        <h3 style="color: #2c3e50;">Occupancy Class Hierarchy</h3>
                        <p style="color: #555;">Breakdown of Occupancy Classes (OCC_CLS) into Primary Occupancy types (PRIM_OCC).</p>
                    </div>
                    <div id="occupancyHierarchySankey"></div>
                </div>

                <!-- OCC_CLS → NSI occtype sankey -->
                <div class="section-header" style="margin-top:24px; padding-top: 8px; border: none;">
                <h3 style="color:#2c3e50;">OCC_CLS → NSI occtype matches</h3>
                <p style="color:#555; margin: 4px 0 12px;">
                    Each link sums the number of NSI points in <em>polygons whose OCC_CLS equals the left-hand class</em>.
                    Counts are pooled per class (RES pool, COM pool, ...); points in other classes do not affect this pool.
                </p>
                </div>

                 <div class="info-box" id="occSankeyNotes" style="margin-top:16px;">
                <h3>Notes on NSI Damage Categories vs. Our Sankey Labels</h3>
                <p>
                    The NSI technical documentation states that certain occtypes are folded into broader
                    <em>‘damage categories’</em> : <strong>AGR</strong> and <strong>REL</strong> are counted under
                    <strong>Commercial</strong>, while <strong>GOV</strong> and <strong>EDU</strong> are counted under
                    <strong>Public</strong>. In this Sankey, we intentionally retain the original occtype labels and do
                    not re-bucket them into those damage-category umbrellas (e.g., <strong>REL is not folded into Commercial</strong>).
                </p>
                </div>
                <div id="occClsOccDictSankey" style="height: 1220px;"></div>



                <div class="chart-container">
                    <div class="section-header" style="margin-top: 0; padding-top: 20px; border: none;">
                        <h3 style="color: #2c3e50;">Occupancy Homogeneity Score (MIX_SC) Distribution</h3>
                        <p style="color: #555;">Distribution of buildings based on the homogeneity of NSI point types within their footprint.</p>
                    </div>
                    <div class="controls" style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                        <div class="toggle-switch">
                            <label for="toggleSameType">Include 'Same Type Only' Category:</label>
                            <input type="checkbox" id="toggleSameType" onchange="createMixScPieChart()" checked>
                        </div>
                    </div>
                    <div id="mixScPieChart"></div>
                    <div class="info-box" style="margin-top: 20px;">
                        <h3>MIX_SC Categories Explained</h3>
                        <p>
                            <strong>Same Type Only (NaN in data):</strong> All NSI points inside the building polygon are of the same primary type as the building itself.<br>
                            <strong>1 Conflict Type (MIX_SC1):</strong> No NSI points of the same type as the building, and all conflicting points are of a single different type.<br>
                            <strong>Same & Different Types (MIX_SC2):</strong> The building contains NSI points of its own type plus one or more conflicting types.<br>
                            <strong>>1 Conflict Types (MIX_SC3):</strong> The building contains no NSI points of the same type as the building, and has two or more different conflicting types.
                        </p>
                    </div>
                </div>



                <div class="export-buttons">
                    <button class="export-button" onclick="exportChart('overviewChart', 'overview')">Export Chart</button>
                    <button class="export-button" onclick="exportAllData()">Export All Data</button>
                </div>

            </div>
            
            <!-- NEW DATA PIPELINES SECTION -->
            <div id="dataAnalysis" class="section">
                <div class="section-header">
                    <h2>Data Pipelines & Processing Pipeline</h2>
                    <p>Understanding the data sources, predictions, cleaning, and distribution</p>
                </div>
                
                <div class="info-box">
                    <h3>Data Pipeline Overview</h3>
                    <p>This section visualizes the journey of forging our powerful, multi-layered dataset from three distinct sources. We began with the USA Structures building inventory(MA only*) as our foundational layer. This base was then systematically enriched, first by incorporating structural characteristics('Year Built', 'Foundation Type', etc.) from the National Structure Inventory(NSI), and second, by adding crucial geotechnical context from the Web Soil Survey. The following diagrams visualize these complex joins, data cleaning procedures, and the final composition of the dataset...</p>
                </div>
                
            <div class="chart-container" style="background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);">
                    <div class="section-header" style="margin-top: 0; padding-top: 20px; border: none;">
                        <h3 style="color: #2c3e50;">NSI-Enhanced USA Structures Dataset Composition</h3>
                        <p style="color: #555;">Click on any data source to explore its contributed columns</p>
                    </div>
                    <div id="dataSourcesFlowchart" style="position: relative; min-height: 500px;"></div>
                    
                    <div id="columnDetailsPanel" style="display: none; background: white; border-radius: 10px; padding: 20px; margin: 20px 0; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                        <h4 id="columnDetailsTitle" style="color: #2c3e50; margin-bottom: 15px;"></h4>
                        <div id="columnDetailsList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px;"></div>
                    </div>
                </div>

            <div class="flowchart-container">
                <!-- Stage 1 -->
                <div class="flow-stage">
                    <h3 class="stage-title collapsible-trigger">
                        Stage 1: Spatial Join to Create NSI Enhanced Version
                        <span class="collapse-icon">▼</span>
                    </h3>
                    <div class="collapsible-content">
                        <div class="flow-content">
                            <div class="flow-inputs">
                                <div class="flow-box data-source usa-structures">
                                    <h4>USA Structures (Base)</h4>
                                    <p>2,091,488 Records</p>
                                    <p>40 Columns</p>
                                </div>
                                <div class="plus-icon">+</div>
                                <div class="flow-box data-source nsi">
                                    <h4>NSI Data Points</h4>
                                    <p>2,095,529 Records</p>
                                    <p>11 Columns Added</p>
                                </div>
                            </div>

                            <div class="flow-arrow">▼</div>
                            
                            <div class="flow-box operation">
                                <h4>Operation: Advanced Multi-Stage Spatial Join</h4>
                                <p>An enhanced, multi-stage process was implemented to accurately enrich building footprints with NSI point data. This updated methodology features flexible handling of mixed-use properties, a precise nearest-neighbor buffer match, and systematic occupancy conflict detection to ensure data quality.</p>
                                <ul>
                                    <li><strong>Strategy 1: Intelligent Single-Family Matching</strong>
                                        <ul>
                                            <li>For buildings classified as 'Single Family', the process now flexibly considers both residential (<code>RES</code>) and commercial (<code>COM</code>) NSI points inside. This accommodates mixed-use scenarios like in-home businesses.</li>
                                            <li><strong>If one point is found,</strong> a direct one-to-one match is made.</li>
                                            <li><strong>If multiple points are found,</strong> their attributes are <strong>aggregated</strong> to create a composite profile, replacing the previous centroid-based selection. This robustly handles properties with multiple distinct units (e.g., a house with a separate commercial unit).</li>
                                        </ul>
                                    </li>
                                    <li><strong>Strategy 2: Standard Aggregation for Other Buildings</strong>
                                        <ul>
                                            <li>For all other building types (multi-family, commercial, etc.), all NSI points falling within the footprint are used.</li>
                                            <li>Their attributes are <strong>aggregated</strong> to create a comprehensive profile for the building:
                                                <ul>
                                                    <li><strong>Value & Area (`structure_value`, `nsi_sqft`):</strong> Summed to get a total.</li>
                                                    <li><strong>Stories (`nsi_num_story`):</strong> The maximum value is taken.</li>
                                                    <li><strong>Characteristics (`year_built`, `material_type`):</strong> The statistical mode (most frequent value) is used.</li>
                                                </ul>
                                            </li>
                                        </ul>
                                    </li>
                                    <li><strong>Strategy 3: Nearest Neighbor Buffer Match</strong>
                                        <ul>
                                            <li>For NSI points that remain unmatched, this strategy finds the <strong>single nearest building polygon</strong> within a <strong>5-meter radius</strong>.</li>
                                            <li>This ensures each point is uniquely assigned to its closest building, correcting for minor spatial inaccuracies. A single building can "absorb" multiple nearby points via this method.</li>
                                            <li>A configurable option also allows buildings already matched in earlier stages to absorb additional nearby points, capturing features like adjacent garages or utility structures.</li>
                                        </ul>
                                    </li>
                                    <li><strong>Extra Feature: Systematic Occupancy Conflict Detection</strong>
                                        <ul>
                                            <li>Throughout the process, the script will actively compare the land use category of the NSI point (e.g., 'Commercial') against the category of the building polygon it falls into (e.g., 'Residential').</li>
                                        </ul>
                                    </li>
                                </ul>
                            </div>

                            <div class="flow-inputs">
                            <div class="flow-box operation" id="stage1-metrics">
                                <details class="stage-panel" >
                                <summary><strong>Stage Details & Unmatched Points(Click for detail)</strong></summary>
                                <div id="stage1MetricsMount"></div>
                                </details>
                            </div>
                            </div>

                                                        
                            <div class="flow-arrow">▼</div>

                            <div class="flow-box result nsi-enhanced">
                                <h4>Result: NSI Enhanced Structures v1</h4>
                                <p>2,091,488 Records</p>
                                <p>51 Columns (40 Base + 11 from NSI)</p>
                                <small>A Left Join was performed, so all original buildings were retained. Unmatched buildings(405,037 in total) have NaN values for NSI columns(year_built, foundation_type, etc.).</small>
                            </div>


                        
                    </div>
                </div>

                </div> <div class="flow-stage">
                    <h3 class="stage-title collapsible-trigger">
                        Stage 1.5: 'Unclassified' buildings from USA Structures were re-defined using NSI point data
                        <span class="collapse-icon">▼</span>
                    </h3>
                    <div class="collapsible-content">
        <div class="info-box" style="border-left-color:#00b894; margin-top:16px;">
            <h3>How we re-label “Unclassified” using <code>OCC_DICT</code></h3>
            <ul style="margin-left: 16px;">
                <li><b>Vote by counts</b> in <code>OCC_DICT</code> (e.g., <code>RES: 0, COM: 8, IND: 1, GOV: 0, EDU: 0 ...</code> → Commercial).</li>
                <li><b>REL is counted as Assembly</b> according to USA Structure PRIM_OCC column (e.g., <code>RES: 1, IND: 1, REL: 2</code> → Assembly).</li>
                <li>If all <code>RES/COM/IND/GOV/EDU/AGR/REL</code> are 0 → keep <b>Unclassified</b>.</li>
                <li>If there is a tie in the vote (e.g., <code>RES: 1, COM: 1</code>), the building will <b>remain Unclassified</b>.</li>
            </ul>
            <p style="margin-top:6px;">
                This relabeling occurs in the data cleaning step before any downstream charts/tables,
                so all occupancy analyses reflect the updated <code>OCC_CLS</code>.
            </p>
        </div>

                        <div class="chart-container" id="unclassifiedResolutionSection">
                            <div class="section-header" style="margin-top: 0; padding-top: 20px; border: none;">
                                <h3 style="color:#2c3e50;">Unclassified Reclassification Summary</h3>
                                <p style="color:#555;">How many Unclassified records were re-labeled into each class</p>
                            </div>

                            <div class="stats-grid">
                                <div class="stat-card">
                                <div class="stat-value" id="unclsTotalBefore">—</div>
                                <div class="stat-label">Total Unclassified (Before)</div>
                                </div>
                                <div class="stat-card">
                                <div class="stat-value" id="unclsWithOccDict">—</div>
                                <div class="stat-label">With OCC_DICT</div>
                                </div>
                                <div class="stat-card">
                                <div class="stat-value" id="unclsChanged">—</div>
                                <div class="stat-label">Changed</div>
                                </div>
                                <div class="stat-card">
                                <div class="stat-value" id="unclsUnchanged">—</div>
                                <div class="stat-label">Kept Unclassified</div>
                                </div>
                            </div>

                            <div id="unclassifiedResolutionTable" style="margin-top:16px;"></div>
                            <div id="unclassifiedTieBreakerSection" style="margin-top: 24px; border: 1px solid #dee2e6; border-radius: 4px; background: #fdfdfd;">
                                <details>
                                    <summary style="padding: 12px; font-weight: 600; color: #2c3e50; cursor: pointer; list-style: inside;">
                                        Tie-Breaker Situations (Kept as Unclassified) - Click to expand
                                    </summary>
                                    <div id="unclassifiedTieBreakerTable" style="padding: 0 12px 12px 12px; border-top: 1px solid #eee; max-height: 300px; overflow-y: auto;">
                                        </div>
                                </details>
                            </div>
                        </div>
                        <div id="unclassifiedDetailsSection" class="info-box" style="border-left-color:#00b894; margin-top:16px; display:none;">
                            <h3>Reclassification Details</h3>
                            <div style="display:flex; gap:12px; align-items:center; margin-bottom:10px;">
                                <label for="reclassFilter">Filter by New Class:</label>
                                <select id="reclassFilter">
                                <option value="All">All</option>
                                <option value="R">Residential</option>
                                <option value="C">Commercial</option>
                                <option value="I">Industrial</option>
                                <option value="G">Government</option>
                                <option value="E">Education</option>
                                <option value="A">Agriculture</option>
                                <option value="S">Assembly</option>
                                </select>

                                <div style="margin-left:auto;">
                                <button id="prevPageBtn">Prev</button>
                                <span id="pageInfo" style="margin:0 8px;">–/–</span>
                                <button id="nextPageBtn">Next</button>
                                </div>
                            </div>

                            <div id="unclassifiedDetailsTable" style="overflow:auto; max-height:460px; border:1px solid #eee;"></div>
                            
                            <div id="unclassifiedDetailsTable" style="overflow:auto; max-height:420px; border:1px solid #eee;"></div>
                        </div>
                        </div>
                </div>

                <!-- Stage 2 -->
                <div class="flow-stage">
                    <h3 class="stage-title collapsible-trigger">
                        Stage 2: Building the Enhanced Soil Layer & Final Join
                        <span class="collapse-icon">▼</span>
                    </h3>
                    <div class="collapsible-content">
                        <div class="flow-content">
                            <div class="flow-inputs">
                                <div class="flow-box data-source nsi-enhanced-input">
                                    <h4>NSI Enhanced Structures v1</h4>
                                    <p>2,091,488 Records (as Points)</p>
                                    <p>50 Columns</p>
                                </div>
                                <div class="plus-icon">+</div>
                                <div class="flow-box data-source soil-survey">
                                    <h4>Web Soil Survey (WSS) Data</h4>
                                    <p>Multiple Source Files:</p>
                                    <small>gsmsoilmu_a_ma.shp, comp.txt, chorizon.txt</small>
                                </div>
                            </div>

                            <div class="flow-arrow">▼</div>
                            <div class="flow-box operation">
                                <h4>Operation: Multi-Step Data Enrichment</h4>
                                <ul>
                                    <li><strong>Part A: Preparing the Enhanced Soil Layer (Double-Filtering)</strong>
                                        <ul>
                                            <li><strong>1. Simplify Soil Components (from `comp.txt`):</strong> For each map unit (`mukey`), only the single **dominant component** (the one with the highest percentage, `comppct_r`) is selected. This provides key attributes like drainage and flooding.</li>
                                            <li><strong>2. Simplify Soil Horizons (from `chorizon.txt`):</strong> For each soil component, only the properties from the **topsoil layer** (`hzdept_r < 10`) are selected to get the engineering properties.</li>
                                            <li><strong>3. Attribute Joins:</strong> The simplified data from steps 1 and 2 are merged (using `cokey`), and then joined with the soil map (`.shp` via `mukey`) to create a single, enriched soil layer where each area is represented by its dominant, topsoil characteristics.</li>
                                        </ul>
                                    </li>
                                    <li><strong>Part B: Final Spatial Join</strong>
                                        <ul>
                                            <li><strong>Method:</strong> Point-in-Polygon intersection (`gpd.sjoin`).</li>
                                            <li><strong>Action:</strong> Each building point is spatially joined with the *enhanced soil layer* from Part A to attach all relevant soil properties.</li>
                                        </ul>
                                    </li>
                                </ul>
                            </div>
                            <div class="flow-arrow">▼</div>
                            
                            <div class="flow-box result final-dataset">
                                <h4>Result: NSI Enhanced Structures v2</h4>
                                <p>2,091,488 Records</p>
                                <p>63 Total Columns (51 + 12 from Soil)</p>
                                <small>A final Left Join ensures all buildings are retained, for those some fall outside the soil map coverage(11,385 buidlings), they haven't been signed any soil-relates data.</small>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="flow-stage">
                    <h3 class="stage-title collapsible-trigger">
                        Stage 3: Enriching with Demolition Permit Data
                        <span class="collapse-icon">▼</span>
                    </h3>
                    <div class="collapsible-content">
                        <div class="flow-content">
                            <div class="flow-inputs">
                                <div class="flow-box result final-dataset" style="background-color: #e8f5e9; border-color: #2E7D32;">
                                <h4>NSI Enhanced Structures v2</h4>
                                <p>2,091,488 Records</p>
                                <p>62 Columns</p>
                                </div>
                                <div class="plus-icon">+</div>
                                <div class="flow-box data-source boston-permits">
                                <h4>Boston Approved Permit Dataset</h4>
                                <p>Demolition Records</p>
                                <p>3 Columns Added</p>
                                </div>
                            </div>
                            <div class="flow-arrow">▼</div>
                            <div class="flow-box operation">
                                <h4>Operation: Intelligent Spatial Enrichment</h4>
                                <ul>
                                <li><strong>1. Priority-Based Deduplication:</strong> Filters permits ('EXTDEM', 'INTDEM', 'RAZE') and selects the "best" record per address, prioritizing <strong>Completed/Closed</strong> status over Open, then the most recent date.</li>
                                <li><strong>2. Project to Local CRS:</strong> Converts coordinates to EPSG:2249 (MA State Plane) for precise meter-based calculations.</li>
                                <li><strong>3. Nearest Neighbor Join:</strong> Finds the single closest permit within a <strong>15-meter radius</strong>. Handles ties (equidistant matches) by strictly enforcing one match per building.</li>
                                <li><strong>4. Non-Destructive Merge:</strong> Uses <strong>Index Alignment</strong> to merge `DEMOLITION_TYPE`, `DEMOLITION_DATE`, and `DEMOLITION_STATUS` back to the original dataset, ensuring zero data loss or row shifting.</li>
                                </ul>
                            </div>
                            <div class="flow-arrow">▼</div>
                            <div class="flow-box data-source nsi-enhanced-input" style="border-color: #2E7D32; background-color: #e8f5e9;">
                                <h4>Result: Final NSI-Enhanced USA Structures Dataset</h4>
                                <p>2,091,488 Records (Exact Match Preserved)</p>
                                <p>65 Total Columns (62 + 3 from Permits)</p>
                                <small>Successfully enriched buildings with demolition data without altering the original dataset structure or row count.</small>
                            </div>
                        </div>
                    </div>
                </div>
            </div>



                <!-- Data Cleaning Sankey -->
                <div class="chart-container">
                    <div class="section-header" style="margin-top: 0; padding-top: 20px; border: none;">
                        <h3 style="color: #2c3e50;">Data Cleaning Process</h3>
                        <p style="color: #555;">How raw data is filtered and cleaned</p>
                    </div>
                    <div id="dataCleaningSankey"></div>
                </div>



                <!-- NSI Data Sources Sankey -->
                <div class="chart-container">
                    <div class="info-box">
                        <h3>NSI Methodology Explained</h3>
                        <p>The National Structural Inventory (NSI) sources key building attributes—such as year built and construction material—primarily from the commercial data provider Lightbox. When gaps or missing values occur in the Lightbox data, the NSI applies a logical random imputation methodology based on HAZUS tables to fill in those gaps. This process helps ensure the dataset’s overall completeness and quality.

The diagram below shows the fill rate of attributes obtained directly from Lightbox. For any missing data, the NSI may have used HAZUS tables as substitutes.</p>
                    </div>
                    <div class="section-header" style="margin-top: 0; padding-top: 20px; border: none;">
                        <h3 style="color: #2c3e50;">NSI Data Sources & Predictions</h3>
                        <p style="color: #555;">How building material and foundation type data are obtained</p>
                    </div>
                    <div id="nsiDataSourcesSankey"></div>
                    <div class="warning-box">
                        <h4>Data Source Information</h4>
                        <p>Lightbox provides 2,542,265 total MA building data records. Building material data is available for 1,208,023 records (47.52% coverage), 
                        and foundation type data for 54,497 records (2.14% coverage). Missing values are predicted using HAZUS methodology.</p>
                    </div>
                </div>

                
            </div>
            <!-- SOIL ANALYSIS SECTION (with modifications) -->
            <div id="soilAnalysis" class="section">
                <div class="section-header">
                    <h2>Soil Properties and Risk Analysis</h2>
                    <p>Comprehensive analysis of soil conditions and their impact on building infrastructure</p>
                </div>
                
                <div class="stats-grid">
                    <div class="stat-card soil-card">
                        <div class="stat-value" id="highRiskBuildings">Loading...</div>
                        <div class="stat-label">High Risk Buildings</div>
                    </div>
                    <div class="stat-card soil-card">
                        <div class="stat-value" id="avgWaterTable">Loading...</div>
                        <div class="stat-label">Avg Water Table (cm)</div>
                    </div>
                    <div class="stat-card soil-card">
                        <div class="stat-value" id="poorDrainageCount">Loading...</div>
                        <div class="stat-label">Poor Drainage Sites</div>
                    </div>
                    <div class="stat-card soil-card">
                        <div class="stat-value" id="floodRiskCount">Loading...</div>
                        <div class="stat-label">Flood Risk Buildings</div>
                    </div>
                </div>
                
                <div class="info-box soil-info">
                    <h3>Soil Data Categories</h3>
                    <p><strong>Drainage Classes:</strong> Well drained, Moderately well drained, Somewhat excessively drained, Poorly drained, Very poorly drained, Excessively drained<br>
                    <strong>Flooding Frequency:</strong> Low, Moderate, High<br>
                    <strong>Engineering Properties:</strong> <= 0.17 Favorable,	> 0.17 and <= 0.24 Fair, > 0.24 and <= 0.32	Poor,  > 0.32 Very poor<br>
                    <strong>Soil Component:</strong> Various soil types identified by compname field</p>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <label>Analysis Type:</label>
                        <select id="soilAnalysisType" onchange="updateSoilAnalysis()">
                            <option value="drainage">Drainage Class</option>
                            <option value="flooding">Flooding Frequency</option>
                            <option value="engineering">Engineering Properties</option>
                            <option value="compname">Soil Component Name</option>
                            <option value="risk">Risk Assessment</option>
                        </select>
                        
                        <div class="toggle-switch">
                            <label>Show Risk Overlay(*For Map plot):</label>
                            <input type="checkbox" id="showRiskOverlay" onchange="updateSoilMap()">
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <div id="soilDistributionChart"></div>
                </div>
                
                <div class="chart-container">
                    <div id="soilByOccupancyChart"></div>
                </div>
                
                <div class="map-container">
                    <div id="soilMap"></div>
                </div>
                
                <div class="chart-container">
                    <div id="waterTableHistogram"></div>
                </div>
                
                <div class="warning-box">
                    <h4>Risk Assessment Methodology</h4>
                    <p>High-risk buildings are identified based on poor drainage conditions (Poorly drained or Very poorly drained) 
                    and/or frequent flooding risk (Occasional or Frequent). These conditions can impact foundation stability, 
                    basement flooding potential, and overall structural integrity over time. Buildings in high-risk zones may 
                    require additional maintenance and waterproofing measures.</p>
                </div>
            </div>

            <!-- CLUSTERING SECTION -->
            <div id="clustering" class="section">
                <div class="section-header">
                    <h2>Clustering Analysis</h2>
                    <p>K-means clustering results based on building area, year built, and occupancy class (using a random sample for visualization)</p>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <label>Number of Clusters:</label>
                        <select id="clusterCount">
                            <option value="5">5 Clusters</option>
                            <option value="6">6 Clusters</option>
                            <option value="7" selected>7 Clusters</option>
                            <option value="8">8 Clusters</option>
                            <option value="9">9 Clusters</option>
                        </select>
                        <button class="control-button" onclick="updateClusteringWithNewK()">Update Analysis</button>
                    </div>
                </div>
                
                <div class="chart-container">
                    <div id="clusterScatter"></div>
                </div>
                
                <div class="chart-container">
                    <div id="clusterElbow"></div>
                </div>
                
                <div class="chart-container">
                    <div id="clusterTable"></div>
                </div>
                
                <div class="chart-container">
                    <div class="control-group">
                        <label>Treemap Size By:</label>
                        <select id="treemapSizeBy" onchange="updateClusterTreemap()">
                            <option value="count">Building Count</option>
                            <option value="area">Total Floor Area</option>
                        </select>
                    </div>
                    <div id="clusterTreemap"></div>
                </div>
            </div>

            <!-- TEMPORAL SECTION -->
            <div id="temporal" class="section">
                <div class="section-header">
                    <h2>Temporal Distribution</h2>
                    <p>Building construction patterns over time with multiple visualization options</p>
                </div>
                
                <div class="warning-box">
                    <h4>Data Quality Note</h4>
                    <p>Some years may have missing or incomplete data (2006, 2009, 2010, 2011, 2013, 2014, 2015, 2016). Years with notably low counts may indicate data collection gaps rather than actual construction patterns. We are currently working on addressing and correcting these gaps. </p>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <label>Chart Type:</label>
                        <select id="chartType" onchange="updateTemporalChart()">
                            <option value="stacked">Stacked Area</option>
                            <option value="line">Line Plot</option>
                            <option value="normalized">Normalized (100%)</option>
                            <option value="cumulative">Cumulative</option>
                        </select>
                        
                        <label>Building Type:</label>
                        <select id="buildingType" onchange="updateTemporalChart()">
                            <option value="all">All Buildings</option>
                            <option value="residential">Residential Only</option>
                            <option value="non-residential">Non-Residential Only</option>
                        </select>
                    </div>
                </div>
                
                <div class="chart-container">
                    <div id="temporalChart"></div>
                </div>
                
                <div class="chart-container">
                    <div id="temporalAreaChart"></div>
                </div>
                
                <div class="chart-container">
                    <div id="temporalTrendChart"></div>
                </div>
            </div>
            
            <!-- PRE-1940 SECTION -->
            <div id="pre1940" class="section">
                <div class="section-header">
                    <h2>Pre-1940 Building Analysis</h2>
                    <p>Detailed analysis of historic buildings constructed before 1940</p>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <label>Building Type Filter:</label>
                        <select id="pre1940Filter" onchange="updatePre1940Charts()">
                            <option value="all">All Buildings</option>
                            <option value="residential">Residential Only</option>
                            <option value="non-residential">Non-Residential Only</option>
                        </select>
                        
                        <div class="toggle-switch">
                            <label></label>
                            <input type="checkbox" id="pre1940Normalize" onchange="updatePre1940Charts()">
                        </div>
                    </div>
                </div>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="pre1940Count">Loading...</div>
                        <div class="stat-label">Pre-1940 Buildings</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="pre1940Percent">Loading...</div>
                        <div class="stat-label">Percentage of Total</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="pre1940Residential">Loading...</div>
                        <div class="stat-label">Residential Buildings</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="pre1940NonRes">Loading...</div>
                        <div class="stat-label">Non-Residential</div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <div id="pre1940PieChart"></div>
                </div>
                
                <div class="chart-container">
                    <div id="pre1940BarChart"></div>
                </div>
                
                <div class="chart-container">
                    <div id="pre1940ComparisonChart"></div>
                </div>
                
                <div class="chart-container">
                    <div id="pre1940AreaChart"></div>
                </div>
            </div>
            
            <!-- POST-1940 SECTION -->
            <div id="post1940" class="section">
                <div class="section-header">
                    <h2>Post-1940 Building Analysis</h2>
                    <p>Modern building construction patterns from 1940 to present (annual data)</p>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <label>Building Type:</label>
                        <select id="post1940BuildingType" onchange="updatePost1940()">
                            <option value="all">All Buildings</option>
                            <option value="residential">Residential Only</option>
                            <option value="non-residential">Non-Residential Only</option>
                        </select>
                        
                        <div class="toggle-switch">
                            <label>Normalize (100% Stack):</label>
                            <input type="checkbox" id="post1940Normalize" onchange="updatePost1940()">
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <div id="post1940Chart"></div>
                </div>
                
                <div class="chart-container">
                    <div id="post1940AreaChart"></div>
                </div>
                
                <div class="chart-container">
                    <div id="decadeComparisonChart"></div>
                </div>
            </div>

            <!-- ENHANCED OCCUPANCY CLUSTERING SECTION -->
            <div id="occupancy" class="section">
                <div class="section-header">
                    <h2>Multi-Dimensional Occupancy Clustering Analysis</h2>
                    <p>Advanced clustering analysis with dynamic feature selection for true multi-dimensional clustering</p>
                </div>
                
                <div class="info-box" style="background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%); border-left-color: #ff9800;">
                    <h3 style="color: #e65100;">Dynamic Clustering Features</h3>
                    <p style="color: #bf360c;">
                        <strong>Base Dimensions (4D):</strong> Year Built, Footprint Area (SQMETERS), Height (HEIGHT_USED — measured HEIGHT when available, otherwise PRED_HEIGHT), Occupancy Class<br>
                        <strong>+ Material Type (5D):</strong> Adds material type as a clustering dimension<br>
                        <strong>+ Foundation Type (5D):</strong> Adds foundation type as a clustering dimension<br>
                        <strong>+ Both (6D):</strong> Includes all dimensions for comprehensive clustering<br>
                        <strong>Real-time Reclustering:</strong> Each toggle change triggers new clustering calculations based on selected features
                    </p>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <label>Select Occupancy Class:</label>
                        <select id="occupancyClass" onchange="updateOccupancyClustering()">
                            <option value="all">All Classes</option>
                            <option value="Residential">Residential</option>
                            <option value="Commercial">Commercial</option>
                            <option value="Industrial">Industrial</option>
                            <option value="Agriculture">Agriculture</option>
                            <option value="Government">Government</option>
                            <option value="Assembly">Assembly</option>
                            <option value="Education">Education</option>
                            <option value="Utility and Misc">Utility & Misc</option>
                            <option value="Unclassified">Unclassified</option>
                        </select>
                        
                        <label>Number of Clusters (K):</label>
                        <select id="occupancyK" onchange="updateOccupancyClustering()">
                            <option value="2">K = 2</option>
                            <option value="3">K = 3</option>
                            <option value="4">K = 4</option>
                            <option value="5" selected>K = 5</option>
                            <option value="6">K = 6</option>
                            <option value="7">K = 7</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <div class="toggle-switch" style="border: 2px solid #4facfe; padding: 10px; border-radius: 8px; background: rgba(79, 172, 254, 0.05);">
                            <label style="font-weight: bold; color: #0066cc;">Include Material Type:</label>
                            <input type="checkbox" id="includeMaterial" onchange="updateOccupancyClustering()">
                            <select id="materialTypeFilter" style="margin-left: 10px; display: none;" onchange="updateOccupancyClustering()">
                                <option value="all">All Materials</option>
                                <option value="W">Wood</option>
                                <option value="M">Masonry</option>
                                <option value="C">Concrete</option>
                                <option value="S">Steel</option>
                                <option value="H">Manufactured</option>
                            </select>
                        </div>
                        
                        <div class="toggle-switch" style="border: 2px solid #00f2fe; padding: 10px; border-radius: 8px; background: rgba(0, 242, 254, 0.05);">
                            <label style="font-weight: bold; color: #0099cc;">Include Foundation Type:</label>
                            <input type="checkbox" id="includeFoundation" onchange="updateOccupancyClustering()">
                            <select id="foundationTypeFilter" style="margin-left: 10px; display: none;" onchange="updateOccupancyClustering()">
                                <option value="all">All Foundations</option>
                                <option value="S">Slab</option>
                                <option value="B">Basement</option>
                                <option value="C">Crawl Space</option>
                                <option value="P">Pier</option>
                                <option value="I">Pile</option>
                                <option value="F">Fill</option>
                                <option value="W">Solid Wall</option>
                            </select>
                        </div>
                        
                        <label>Sample Type:</label>
                        <select id="sampleType" onchange="updateOccupancyClustering()" style="border: 2px solid #bd3786; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);">
                            <option value="balanced" selected>Balanced Sample (Equal Representation)</option>
                            <option value="random">Random Sample (True Distribution)</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label>Sample Size for Visualization:</label>
                        <select id="sampleSize" onchange="updateOccupancyClustering()">
                            <option value="1000">1,000 buildings</option>
                            <option value="5000" selected>5,000 buildings</option>
                            <option value="10000">10,000 buildings</option>
                            <option value="20000">20,000 buildings</option>
                        </select>
                        
                        <div class="toggle-switch">
                            <label>Log Scale (Area):</label>
                            <input type="checkbox" id="logScale" onchange="updateOccupancyClustering()">
                        </div>
                    </div>
                    
                    <div style="margin-top: 15px; padding: 12px; background: linear-gradient(135deg, #f0f4ff 0%, #e8f0ff 100%); border-radius: 8px; border-left: 4px solid #667eea;">
                        <div id="sampleTypeIndicator" style="font-size: 14px; color: #495057;">
                            <strong>Current View:</strong> <span id="currentSampleType" style="color: #7201a8; font-weight: bold;">Balanced Sample</span> - 
                            <span id="sampleDescription" style="color: #666;">Shows equal representation of all occupancy classes for better pattern visibility</span>
                        </div>
                        <div id="clusteringDimensions" style="margin-top: 8px; font-size: 14px; color: #495057;">
                            <strong>Active Clustering Dimensions:</strong> <span id="activeDimensions" style="color: #667eea; font-weight: bold;">Year, Area, Occupancy (3D)</span>
                        </div>
                        <div id="clusteringStatus" style="margin-top: 8px; font-size: 14px; color: #495057;">
                            <strong>Clustering Status:</strong> <span id="clusteringStatusText" style="color: #4facfe; font-weight: bold;">Using pre-computed base clustering</span>
                        </div>
                        <div id="filterStatus" style="margin-top: 8px; font-size: 14px; color: #495057; display: none;">
                            <strong>Active Filters:</strong> <span id="activeFilters" style="color: #4facfe; font-weight: bold;"></span>
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <div id="occupancyClusterChart"></div>
                </div>
                
                <div class="chart-container">
                    <div id="occupancyFullStatsChart"></div>
                </div>
                
                <div class="chart-container">
                    <div id="occupancySampleStatsChart"></div>
                </div>
                
                <div class="chart-container">
                    <div id="occupancyElbowChart"></div>
                </div>
            </div>

            <!-- MATERIALS SECTION -->
            <div id="materials" class="section">
                <div class="section-header">
                    <h2>Building Materials & Foundation Analysis</h2>
                    <p>Correlation between material types and foundation types - Click on any cell to see occupancy breakdown</p>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <label>Data Filter:</label>
                        <select id="materialFilter" onchange="updateMaterialsHeatmap()">
                            <option value="all">All Buildings</option>
                            <option value="pre1940">Pre-1940 Only</option>
                            <option value="post1940">Post-1940 Only</option>
                        </select>
                        
                        <div class="toggle-switch">
                            <label>Log Scale (Heatmap Only):</label>
                            <input type="checkbox" id="heatmapLogScale" onchange="updateHeatmapOnly()">
                        </div>
                        
                        <label style="margin-left: 20px;">Breakdown Chart Type:</label>
                        <select id="breakdownChartType" onchange="updateOccupancyBreakdown()">
                            <option value="pie">Pie Chart</option>
                            <option value="bar">Bar Chart</option>
                            <option value="horizontal-bar">Horizontal Bar</option>
                        </select>
                    </div>
                </div>
                
                <div class="info-box">
                    <h3>Material & Foundation Type Codes</h3>
                    <p><strong>Material Types:</strong> M = Masonry, W = Wood, H = Manufactured, S = Steel, C = Concrete<br>
                    <strong>Foundation Types:</strong> C = Crawl Space, B = Basement, S = Slab, P = Pier, I = Pile, F = Fill, W = Solid Wall<br>
                    <strong style="color: #667eea;">👉 Click on any cell in either heatmap to see the occupancy class distribution for that combination</strong></p>
                </div>
                
                <!-- Heatmap tabs for switching between count and area -->
                <div class="heatmap-tabs">
                    <button class="heatmap-tab active" id="countHeatmapTab" onclick="showHeatmap('count')">Building Count</button>
                    <button class="heatmap-tab" id="areaHeatmapTab" onclick="showHeatmap('area')">Total Est GFA (sqm)</button>
                </div>
                
                <div class="chart-container" id="countHeatmapContainer">
                    <div id="materialsHeatmap"></div>
                </div>
                
                <div class="chart-container" id="areaHeatmapContainer" style="display: none;">
                    <div id="materialsAreaHeatmap"></div>
                </div>
                
                <div class="chart-container" id="occupancyBreakdownContainer" style="display: none;">
                    <div class="section-header" style="margin-top: 0; padding-top: 20px;">
                        <h3 id="breakdownTitle">Occupancy Class Distribution</h3>
                        <p id="breakdownSubtitle">Click on a heatmap cell to see the breakdown</p>
                    </div>
                    <div id="occupancyBreakdownChart"></div>
                </div>
                
                <div class="chart-container">
                    <div class="section-header" style="margin-top: 0; padding-top: 20px; border: none;">
                        <h3 style="color: #2c3e50;">Material Usage Trends Over Time</h3>
                        <p style="color: #555;">Normalized percentage of material types for new construction in each decade.</p>
                    </div>
                    <div class="controls" style="margin-bottom: 20px;">
                        <div class="control-group">
                            <label>Normalize By:</label>
                            <select id="materialTrendNormalizeBy" onchange="createMaterialTrendsChart()">
                                <option value="count">Building Count</option>
                                <option value="gfa">Est GFA (sqm)</option>
                            </select>
                        </div>
                    </div>
                    <div id="materialsTrendChart"></div>
                </div>

            </div>


            <div id="historicShoreline" class="section">
                <div class="section-header">
                    <h2>Boston's Historic Shoreline and Filled Land</h2>
                    <p>Visualizing buildings constructed on land reclaimed since 1630.</p>
                </div>
                
                <div class="info-box">
                    <h3>The Filling of Boston</h3>
                    <p>
                        The map of Boston has changed dramatically since its founding in 1630. Much of what is now considered central Boston was once tidal flats and marshes. 
                        Through extensive land reclamation projects over centuries, areas like Back Bay, the South End, and parts of Downtown were created from fill. 
                        This historic map shows the original 1630 shoreline, and the interactive map below displays modern buildings that now stand on this reclaimed land.
                    </p>
                </div>

                <div class="chart-container">
                    <h3>Historic Shoreline Map (c. 1630)</h3>
                    <img src="boston_shoreline_1630.png" alt="Historic Map of Boston Shoreline" style="width: 100%; height: auto; border-radius: 10px;">
                </div>
                
                <div class="section-header" style="margin-top: 40px;">
                    <h2>Buildings on Reclaimed Land</h2>
                    <p>An interactive map of structures located on areas that were filled after 1630.</p>
                </div>

                <div class="controls">
                    <div class="control-group">
                        <label>Filter by Occupancy:</label>
                        <select id="historicOccFilter" onchange="updateHistoricShorelineCharts()"></select>
                        
                        <label>Filter by Material:</label>
                        <select id="historicMaterialFilter" onchange="updateHistoricShorelineCharts()"></select>
                        
                        <label>Filter by Foundation:</label>
                        <select id="historicFoundationFilter" onchange="updateHistoricShorelineCharts()"></select>
                    </div>
                    <div class="control-group">
                        <label>Color Points By:</label>
                        <select id="historicColorBy" onchange="updateHistoricShorelineCharts()">
                            <option value="OCC_CLS">Occupancy Class</option>
                            <option value="material_type">Material Type</option>
                            <option value="foundation_type">Foundation Type</option>
                        </select>
                    </div>
                </div>

                <div class="map-container">
                    <div id="historicShorelineMapPlot"></div>
                </div>

                                <div class="stats-grid" style="margin-top: 30px; grid-template-columns: repeat(auto-fit, minmax(48%, 1fr));">
                    
                    <div class="chart-container">
                        <div id="historicOccupancyChart"></div>
                    </div>
                    
                    <div class="chart-container">
                        <div id="historicYearChart"></div>
                    </div>
                    
                    <div class="chart-container">
                        <div id="historicMaterialChart"></div>
                    </div>

                    <div class="chart-container">
                        <div id="historicFoundationChart"></div>
                    </div>
                </div>
            </div>

<div id="interactive" class="section">
                <div class="section-header">
                    <h2>Interactive Data Explorer</h2>
                    <p>Explore the data with custom filters and advanced visualizations (*Data from 75,000 random sampled data from 1.7M cleaned dataset)</p>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <label>Year Range:</label>
                        <input type="number" id="yearStart" value="1900" min="1900" max="2024" style="width: 100px">
                        <span>to</span>
                        <input type="number" id="yearEnd" value="2024" min="1900" max="2024" style="width: 100px">
                    </div>
                    <div class="control-group">
                        <label>Est GFA Range (sqm):</label>
                        <input type="number" id="areaMin" value="0" min="0" style="width: 100px">
                        <span>to</span>
                        <input type="number" id="areaMax" value="10000" min="0" style="width: 100px">
                    </div>
                    <div class="control-group">
                        <label>Visualization:</label>
                        <select id="vizType">
                            <option value="box">Box Plot</option>
                            <option value="scatter3d">3D Scatter Plot</option>
                            <option value="sunburst">Sunburst Chart</option>
                            <option value="parallel">Parallel Coordinates</option>
                            <option value="violin">Violin Plot</option>
                            <option value="treemap">Treemap</option>
                        </select>
                        <button class="control-button" onclick="updateInteractiveExplorer()">Update Visualization</button>
                    </div>
                </div>
                
                <div class="chart-container">
                    <div id="interactiveChart"></div>
                </div>
                
                <div class="info-box">
                    <h3>Tips for Interactive Explorer</h3>
                    <p>• 3D Scatter: Rotate with mouse, zoom with scroll wheel<br>
                       • Sunburst: Click segments to zoom in, click center to zoom out<br>
                       • Parallel Coordinates: Drag axes to reorder, brush to filter<br>
                       • All charts: Hover for details, double-click to reset view</p>
                </div>
            </div>
            
            <div id="clf" class="section">
                <div class="section-header">
                    <h2>CLF Data Analysis</h2>
                    <p>Analysis of Carbon Leadership Forum dataset for Massachusett</p>
                </div>

                <div class="info-box">
                    <h3>CLF Data Preprocessing</h3>
                    <p>This dataset originates from the New Construction MA Projects from the CLF building metadata, processed to be compatible with the NSI Enhanced USA Structure dataset. Key transformations include:</p>
                    
                    <h4 style="margin-top: 15px;">Occupancy Classification (OCC_CLS)</h4>
                    <p style="font-size: 0.9em; margin-bottom: 10px;">
                        Detailed CLF building uses were mapped to NSI Enhanced USA Structure dataset categories. 
                        <strong>This mapping is primarily based on the definitions from the USA Structure dataset's <code>PRIM_OCC</code> column.</strong>
                    </p>
                    <table style="width: 100%; border-collapse: collapse; font-size: 0.9em;">
                        <thead style="background-color: #f0f4f8;">
                            <tr>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: left;">CLF Building Use</th>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Mapped NSI Category (OCC_CLS)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr><td style="border: 1px solid #ddd; padding: 8px;">Multifamily (5 or more units)</td><td style="border: 1px solid #ddd; padding: 8px;">Residential</td></tr>
                            <tr><td style="border: 1px solid #ddd; padding: 8px;">Lodging</td><td style="border: 1px solid #ddd; padding: 8px;">Residential</td></tr>
                            
                            <tr><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Office</td><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Commercial</td></tr>
                            <tr><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Mercantile</td><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Commercial</td></tr>
                            <tr><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Food Service</td><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Commercial</td></tr>
                            <tr><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Laboratory</td><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Commercial</td></tr>
                            <tr><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Healthcare</td><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Commercial</td></tr>
                            <tr><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Parking</td><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Commercial</td></tr>

                            <tr><td style="border: 1px solid #ddd; padding: 8px;">Public Order and Safety</td><td style="border: 1px solid #ddd; padding: 8px;">Government</td></tr>
                            
                            <tr><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Warehouse and Storage</td><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Industrial</td></tr>
                            <tr><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Industrial</td><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Industrial</td></tr>

                            <tr><td style="border: 1px solid #ddd; padding: 8px;">Public Assembly</td><td style="border: 1px solid #ddd; padding: 8px;">Assembly</td></tr>
                            <tr><td style="border: 1px solid #ddd; padding: 8px;">Religious Worship</td><td style="border: 1px solid #ddd; padding: 8px;">Assembly</td></tr>
                            <tr><td style="border: 1px solid #ddd; padding: 8px;">Transportation Hub</td><td style="border: 1px solid #ddd; padding: 8px;">Assembly</td></tr>
                            
                            <tr><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Education</td><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Education</td></tr>
                            <tr><td style="border: 1px solid #ddd; padding: 8px;">Other</td><td style="border: 1px solid #ddd; padding: 8px;">Utility and Misc</td></tr>
                        </tbody>
                    </table>

                    <h4 style="margin-top: 20px;">Material Type Encoding (material_type)</h4>
                    <p style="font-size: 0.9em; margin-bottom: 10px;">
                        CLF structural systems were mapped to single-letter codes. 
                        <strong>This mapping was inferred by combining several CLF columns: <code>str_prim_horiz_sys</code>, <code>str_prim_vert_sys</code>, <code>str_lat_sys</code>, and <code>str_sec_vert_sys</code>.</strong>
                    </p>
                    <table style="width: 100%; border-collapse: collapse; font-size: 0.9em;">
                        <thead style="background-color: #f0f4f8;">
                            <tr>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: left;">CLF Structural System</th>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Mapped Code (material_type)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr><td style="border: 1px solid #ddd; padding: 8px;">Steel</td><td style="border: 1px solid #ddd; padding: 8px;">S</td></tr>
                            <tr><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Concrete</td><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">C</td></tr>
                            <tr><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Steel/Concrete</td><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">S</td></tr>
                            <tr><td style="border: 1px solid #ddd; padding: 8px;">Steel/Masonry</td><td style="border: 1px solid #ddd; padding: 8px;">S</td></tr>
                            <tr><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Wood: Mass Timber</td><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">W</td></tr>
                            <tr><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Wood: Light-frame</td><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">W</td></tr>
                            <tr><td style="border: 1px solid #ddd; padding: 8px;">Other</td><td style="border: 1px solid #ddd; padding: 8px;">H</td></tr>
                            <tr>
                                <td colspan="2" style="border: 1px solid #dddddd; padding: 8px; text-align: left; background-color: #9fc5af; font-style: italic;">
                                    M = Masonry, W = Wood, H = Manufactured, S = Steel, C = Concrete    (in NSI Enhanced USA Strucuture dataset)
                                </td>
                            </tr>
                        </tbody>
                    </table>

                    <h4 style="margin-top: 20px;">Other Key Transformations</h4>
                    <ul style="margin-left: 20px; margin-top: 10px; font-size: 0.9em; list-style-type: '→ '; padding-left: 15px;">
                        <li style="padding-left: 5px;"><code>bldg_compl_year</code> was mapped to <code>year_built</code></li>
                        <li style="padding-left: 5px; margin-top: 5px;"><code>bldg_cfa</code> was mapped to <code>Est GFA sqmeters</code></li>
                        <li style="padding-left: 5px; margin-top: 5px;"><code>str_fdn_type</code> was mapped to <code>general_fnd_type</code></li>
                        <li style="padding-left: 5px; margin-top: 5px;"><strong>Height Standardization:</strong> Text descriptions (e.g., "10-12 m") were converted to numeric averages (e.g., 11 in the HEIGHT column, which is in meters).</li>
                        <li style="padding-left: 5px; margin-top: 5px;"><strong>Data Cleaning:</strong> 2 Records with missing floor area data (Est GFA sqmeters) were removed.</li>

                        <li style="padding-left: 5px; margin-top: 5px;"><strong>Finally 16 projects from CLF are analyzed</strong> </li>
                    </ul>
                </div>

<div class="chart-container">
    <div class="section-header" style="border: none; margin-bottom: 20px;">
        <h3>Scatter Plot CLF MA Data Explorer</h3>
        <p>Compare GFA, Total Mass, and GWP, colored by Occupancy Class.</p>
    </div>

    <div class="controls" style="background: #f8f9fa;">
        
        <div class="control-group">
            <label for="clfXAxis">X-Axis:</label>
            <select id="clfXAxis" onchange="createCLFScatterPlot()">
                <option value="Est GFA sqmeters" selected>Est GFA (sqm)</option>
                <option value="mass_total">Total Mass</option>
                <option value="gwp_a_to_c">GWP (A-C)</option>
            </select>
            <label for="clfYAxis">Y-Axis:</label>
            <select id="clfYAxis" onchange="createCLFScatterPlot()">
                <option value="Est GFA sqmeters">Est GFA (sqm)</option>
                <option value="mass_total" selected>Total Mass</option>
                <option value="gwp_a_to_c">GWP (A-C)</option>
            </select>
        </div>
        
        <div class="control-group">
            <div class="toggle-switch">
                <label for="clfLogToggle">Use Log Scale:</label>
                <input type="checkbox" id="clfLogToggle" onchange="createCLFScatterPlot()" checked>
            </div>
        </div>

    </div> <div id="clfScatterPlot" style="min-height: 500px;"></div>

                <div class="chart-container">
                    <div class="section-header" style="border: none; margin-bottom: 10px;">
                        <h3>CLF Heatmap Analysis</h3>
                        <p>Correlation between foundation types and structural systems.</p>
                    </div>

                    <div class="heatmap-tabs" style="margin-bottom: 15px;">
                        <button class="heatmap-tab active" id="clfHeatmapTabCount" onclick="setCLFHeatmapMetric('count')">
                            By Building Count
                        </button>
                        <button class="heatmap-tab" id="clfHeatmapTabGFA" onclick="setCLFHeatmapMetric('gfa')">
                            By Total Est. GFA (sqm)
                        </button>
                    </div>

                    <div class="section-header" style="border: none; margin: 20px 0 10px 0; padding: 0;">
                        <h4 style="font-size: 1.2em;">Mapped Material Type vs. Foundation Type</h4>
                    </div>
                    <div id="clfHeatmap" style="min-height: 500px;"></div>
                    
                    <div class="section-header" style="border: none; margin: 30px 0 10px 0; padding: 0;">
                        <h4 style="font-size: 1.2em;">Original Structural System vs. Foundation Type</h4>
                    </div>
                    <div id="clfStructHeatmap" style="min-height: 500px;"></div>
                </div>

                <div class="chart-container">
                    <div class="section-header" style="border: none; margin-bottom: 20px;">
                        <h3>GFA Distribution: Main Dataset vs. CLF Dataset</h3>
                        <p>Comparison of Est GFA (sqm) by Occupancy Class. Boxes represent the main dataset (from 75,000 random sampled data from 1.7M cleaned dataset); 'x' markers represent the CLF dataset.</p>
                    </div>
                    <div id="clfBoxPlotOverlay" style="min-height: 500px;"></div>
                </div>

            </div>
            
            <div class="error-box" id="errorBox">
                <h3>Error Loading Data</h3>
                <p id="errorMessage">Unable to load building data. Please ensure building_data.json is in the same directory.</p>
            </div>
        
        </div>
    
    </div>
    
    <script>
        // Global variables for data
        let buildingData = null;
        let historicShorelineData = null;
        let clfData = null;
        let currentCLFHeatmapMetric = 'count';
        let isDataLoaded = false;
        let currentClusterK = 7;
        
        // Global variables for material selection
        let currentMaterialSelection = null;
        let currentOccupancyData = null;
        let currentHeatmapType = 'count';
        
        // Global variables for soil analysis
        let soilAnalysisData = null;
        let soilMapData = null;
        
        // Plasma colorscale
        const plasmaColorscale = 'Plasma';
        const plasmaColors = [
            '#0d0887', '#46039f', '#7201a8', '#9c179e', '#bd3786',
            '#d8576b', '#ed7953', '#fb9f3a', '#fdca26', '#f0f921'
        ];
        
        // Soil-specific colors
        const soilColors = {
            drainage: {
                'Well drained': '#2E7D32',
                'Moderately well drained': '#66BB6A',
                'Somewhat excessively drained': '#FDD835',
                'Poorly drained': '#FF9800',
                'Very poorly drained': '#E53935',
                'Excessively drained': '#1565C0'
            },
            flooding: {
                'Low': '#FDD835', 
                'Moderate': '#FF9800', 
                'High': '#E53935'
            },
            engineering: {
                'Favorable': '#2E7D32',
                'Fair': '#FDD835',
                'Poor': '#FF9800',
                'Very poor': '#E53935'
            }
        };
        
        // Material and Foundation type mappings
        const materialTypeMap = {
            'M': 'Masonry',
            'W': 'Wood',
            'H': 'Manufactured',
            'S': 'Steel',
            'C': 'Concrete'
        };
        
        const foundationTypeMap = {
            'C': 'Crawl Space',
            'B': 'Basement',
            'S': 'Slab',
            'P': 'Pier',
            'I': 'Pile',
            'F': 'Fill',
            'W': 'Solid Wall'
        };
        
        function getPlasmaColors(n) {
            if (n <= 10) return plasmaColors.slice(0, n);
            const colors = [];
            for (let i = 0; i < n; i++) {
                const idx = Math.floor(i * 9 / (n - 1));
                colors.push(plasmaColors[Math.min(idx, 9)]);
            }
            return colors;
        }
        
        window.addEventListener('error', function(event) {
            console.error('Error details:', event);
            return true;
        });

        const originalNewPlot = Plotly.newPlot;
        Plotly.newPlot = function(gd, data, layout, config) {
            try {
                if (Array.isArray(data)) {
                    data.forEach(trace => {
                        if (trace && trace.marker && typeof trace.marker === 'object') {
                            if (trace.marker.line === undefined) {
                                delete trace.marker.line;
                            }
                        }
                    });
                }
                return originalNewPlot.call(this, gd, data, layout, config);
            } catch (error) {
                console.error('Plotly error:', error);
                return Promise.resolve();
            }
        };

        document.addEventListener('DOMContentLoaded', function() {
            loadData();
            
            // Toggle material/foundation filter visibility
            document.getElementById('includeMaterial').addEventListener('change', function() {
                document.getElementById('materialTypeFilter').style.display = this.checked ? 'inline-block' : 'none';
                updateOccupancyClustering();
            });
            
            document.getElementById('includeFoundation').addEventListener('change', function() {
                document.getElementById('foundationTypeFilter').style.display = this.checked ? 'inline-block' : 'none';
                updateOccupancyClustering();
            });
            
            // NEW: re-render the Year→Occ→... Sankey when toggles change
            document.getElementById('toggleMaterial').addEventListener('change', createYearOccSankey);
            document.getElementById('toggleFoundation').addEventListener('change', createYearOccSankey);
            document.getElementById('toggleSoil').addEventListener('change', createYearOccSankey);

    
        });
        
        
        // NEW: Data Pipelines Section Functions
        function createDataPipelinesDiagrams() {
            // This function calls all the necessary functions to build the charts in the "Data Pipelines" section.
            createNSIDataSourcesSankey();
            createOccupancyHierarchySankey();
            createOccClsOccDictSankey();
            createDataCleaningSankey();
            createBuildingDistributionSankey(); // This will call the function we previously fixed.
            createYearOccSankey();
        }

        
        const stage1Stats = {
        strategy1: {
            mixed_use_single_family_flagged: 15638,
            matched_single_family_one_to_one: 1112984,
            matched_single_family_aggregated: 21283
        },
        strategy2: { matched_multiunit_commercial: 366340 },
        funnel: {
            initial: { nsi_points: 2095529, usa_polygons: 2091488 },
            after_pip: { unmatched_nsi_points: 423281, unmatched_usa_polygons: 590881 }, // Stages 1 & 2
            after_buffer: { final_unmatched_nsi_points: 183289, final_unmatched_usa_polygons: 405037 } // Stage 3
        },
        occupancy_conflicts: 146184,
        performance: {
            total_buildings: 2091488,
            buildings_matched: 1686451,
            buildings_with_occupancy_conflict: 86817,
            final_match_rate: 80.63
        },
        match_type_distribution: [
            ["residential_single_point", 1100668, "65.27%"],
            ["multi_unit_aggregated", 357852, "21.22%"],
            ["buffer_attach", 185844, "11.02%"],
            ["residential_aggregated", 20255, "1.20%"],
            ["buffer_attach|residential_single_point", 12316, "0.73%"],
            ["buffer_attach|multi_unit_aggregated", 8488, "0.50%"],
            ["buffer_attach|residential_aggregated", 1028, "0.06%"]
        ]
        };


        function renderStage1Metrics(stats){
        const mount = document.getElementById('stage1MetricsMount');
        if (!mount) return;
        const fmt = n => Number(n).toLocaleString();

        mount.innerHTML = `
        <details open>
            <summary><strong>Strategy 1: intelligent matching for single-family homes</strong></summary>
            <ul>
            <li>single-family buildings flagged as mixed-use (indoor RES+non-RES): ${fmt(stats.strategy1.mixed_use_single_family_flagged)}</li>
            <li>matched single-family buildings (1-to-1): ${fmt(stats.strategy1.matched_single_family_one_to_one)}</li>
            <li>matched single-family buildings (aggregated): ${fmt(stats.strategy1.matched_single_family_aggregated)}</li>
            </ul>
        </details>

        <details open>
            <summary><strong>Strategy 2: multi-unit/commercial aggregated matching</strong></summary>
            <ul>
            <li>matched multi-unit/commercial buildings: ${fmt(stats.strategy2.matched_multiunit_commercial)}</li>
            </ul>
        </details>

        <details open>
            <summary><strong>Match Funnel & Unmatched Entity Report</strong></summary>
            <div class="funnel-grid">
                <div class="funnel-block">
                <em>Initial State</em>
                <div>– Total NSI Points: ${fmt(stats.funnel.initial.nsi_points)}</div>
                <div>– Total USA Polygons: ${fmt(stats.funnel.initial.usa_polygons)}</div>
                </div>
                <div class="funnel-block">
                <em>After Stages 1 & 2</em>
                <div>– Remaining Unmatched NSI Points: ${fmt(stats.funnel.after_pip.unmatched_nsi_points)}</div>
                <div>– Remaining Unmatched USA Polygons: ${fmt(stats.funnel.after_pip.unmatched_usa_polygons)}</div>
                </div>
                <div class="funnel-block span-2">
                <em>After Buffer/Nearest Neighbor (Stage 3)</em>
                <div>– Final Unmatched NSI Points: ${fmt(stats.funnel.after_buffer.final_unmatched_nsi_points)}</div>
                <div>– Final Unmatched USA Polygons: ${fmt(stats.funnel.after_buffer.final_unmatched_usa_polygons)}</div>
                </div>
            </div>
        </details>

        <details open>
            <summary><strong>Occupancy Conflict Report</strong></summary>
            <div>Total Occupancy Conflicts Detected: ${fmt(stats.occupancy_conflicts)}</div>
        </details>

        <details open>
            <summary><strong>Overall Match Performance</strong></summary>
            <ul>
            <li>Total Number of Buildings in Dataset: ${fmt(stats.performance.total_buildings)}</li>
            <li>Total Buildings with a Successful Match: ${fmt(stats.performance.buildings_matched)}</li>
            <li>Total Buildings with Occupancy Conflict: ${fmt(stats.performance.buildings_with_occupancy_conflict)}</li>
            <li>Final Match Rate: ${stats.performance.final_match_rate}%</li>
            </ul>
        </details>

        <details>
            <summary><strong>Match Type Distribution</strong></summary>
            <div id="matchTypeTable"></div>
        </details>
        `;

    
        const table = document.createElement('table');
        table.style.width = '100%';
        table.style.borderCollapse = 'collapse';
        table.innerHTML = `
            <thead><tr>
            <th style="text-align:left;padding:6px;border-bottom:1px solid #ddd;">Match type</th>
            <th style="text-align:right;padding:6px;border-bottom:1px solid #ddd;">Count</th>
            <th style="text-align:right;padding:6px;border-bottom:1px solid #ddd;">Share</th>
            </tr></thead>
            <tbody>
            ${stats.match_type_distribution.map(([label, count, pct]) => `
                <tr>
                <td style="padding:6px;border-bottom:1px solid #eee;">${label}</td>
                <td style="padding:6px;border-bottom:1px solid #eee;text-align:right;">${fmt(count)}</td>
                <td style="padding:6px;border-bottom:1px solid #eee;text-align:right;">${pct}</td>
                </tr>`).join('')}
            </tbody>`;
        document.getElementById('matchTypeTable').appendChild(table);
        }


        document.addEventListener('DOMContentLoaded', () => renderStage1Metrics(stage1Stats));


        document.addEventListener('DOMContentLoaded', function() {
            const triggers = document.querySelectorAll('.collapsible-trigger');

            triggers.forEach(trigger => {
                const icon = trigger.querySelector('.collapse-icon');
                icon.style.transform = 'rotate(-90deg)'; 
            });

            triggers.forEach(trigger => {
                trigger.addEventListener('click', function() {
                    const content = this.nextElementSibling;
                    const icon = this.querySelector('.collapse-icon');

                    this.classList.toggle('active');
                    content.classList.toggle('active');

                    if (content.classList.contains('active')) {
                        icon.style.transform = 'rotate(0deg)'; 
                    } else {
                        icon.style.transform = 'rotate(-90deg)'; 
                    }
                });
            });
        });

        function createNSIDataSourcesSankey() {
            // This function creates the Sankey diagram showing the sources of NSI data (Lightbox vs. HAZUS).
            // These are hardcoded values representing the general NSI methodology.
            const totalRecords = 2542265;
            const materialFromLightbox = 1208023;
            const foundationFromLightbox = 54497;
            const materialPredicted = totalRecords - materialFromLightbox;
            const foundationPredicted = totalRecords - foundationFromLightbox;
            
            const sankeyData = [{
                type: 'sankey',
                orientation: 'h',
                node: {
                    pad: 15,
                    thickness: 30,
                    line: { color: 'white', width: 2 },
                    label: [
                        'Building Material', // Index 0
                        'Foundation Type', // Index 1
                        'Material from Lightbox<br>(47.52%)', // Index 2
                        'Material Predicted by NSI, using HAZUS Table<br>(52.48%)', // Index 3
                        'Foundation from Lightbox<br>(2.14%)', // Index 4
                        'Foundation Predicted by NSI, using HAZUS Table<br>(97.86%)'  // Index 5
                    ],
                    color: ['#bd3786', '#f5576c', '#4facfe', '#fa709a', '#4facfe', '#fa709a']
                },
                link: {
                    source: [0, 0, 1, 1],
                    target: [2, 3, 4, 5],
                    value: [materialFromLightbox, materialPredicted, foundationFromLightbox, foundationPredicted],
                    color: ['#4facfe40', '#fa709a40', '#4facfe40', '#fa709a40']
                }
            }];
            
            const layout = {
                title: { text: 'NSI Data Sources: Lightbox vs HAZUS Predictions', font: { size: 18, color: '#333' } },
                font: { size: 12 },
                height: 500
            };
            
            Plotly.newPlot('nsiDataSourcesSankey', sankeyData, layout, {responsive: true});
        }

        function createOccupancyHierarchySankey() {
                    if (!buildingData || !buildingData.occupancy_hierarchy_sankey) {
                        console.warn('No occupancy hierarchy data available');
                        document.getElementById('occupancyHierarchySankey').innerHTML = '<p>Occupancy hierarchy data not available.</p>';
                        return;
                    }

                    const data = buildingData.occupancy_hierarchy_sankey;
                    
                    const occClsNodes = data.nodes.filter(n => n.name.endsWith(' (Class)'));
                    
                    const baseColors = getPlasmaColors(occClsNodes.length);
                    const occClsColorMap = {};
                    occClsNodes.forEach((node, index) => {
                        occClsColorMap[node.name] = baseColors[index];
                    });
                    
                    const nodeColors = data.nodes.map(node => occClsColorMap[node.name] || '#cccccc');
                    const linkColors = data.links.source.map(sourceIndex => {
                        const sourceNodeName = data.nodes[sourceIndex].name;
                        const color = occClsColorMap[sourceNodeName] || '#cccccc';
                        return color.replace(')', ', 0.4)').replace('rgb', 'rgba');
                    });
                    
                    const originalValues = data.links.value;


                    const scaledValues = originalValues.map(v => Math.sqrt(v));

                    const originalNodeTotals = Array(data.nodes.length).fill(0);
                    data.links.source.forEach((sourceIndex, i) => {
                        const targetIndex = data.links.target[i];
                        const value = originalValues[i];
                        originalNodeTotals[sourceIndex] += value;
                        originalNodeTotals[targetIndex] += value;
                    });

                    const sankeyData = [{
                        type: 'sankey',
                        orientation: 'h',
                        node: {
                            pad: 20,
                            thickness: 20,
                            line: { color: 'white', width: 1.5 },
                            label: data.nodes.map(n => n.name),
                            color: nodeColors,
                            customdata: originalNodeTotals,
                            hovertemplate: '<b>%{label}</b><br>Total Count: %{customdata:,}<extra></extra>'
                        },
                        link: {
                            source: data.links.source,
                            target: data.links.target,
                            value: scaledValues,
                            color: linkColors,
                            customdata: originalValues,
                            hovertemplate: '%{source.label} → %{target.label}<br><b>Count: %{customdata:,}</b><extra></extra>'
                        }
                    }];

                    const layout = {
                        title: {
                            text: 'Flow from Occupancy Class to Primary Occupancy',
                            font: { size: 18, color: '#333' }
                        },
                        font: { size: 10 },

                        height: 1200 
                    };

                    Plotly.newPlot('occupancyHierarchySankey', sankeyData, layout, {responsive: true});
                }

        // Build OCC_CLS → NSI occtype sankey.
        // Prefer pre-aggregated data from Python (buildingData.occ_cls_occ_dict_sankey).
        // Fallback to compute from samples only if aggregation is missing.
        function createOccClsOccDictSankey() {
        const container = document.getElementById('occClsOccDictSankey');
        if (!container) return;

        if (!buildingData) {
            container.innerHTML = '<p>Data not loaded.</p>';
            return;
        }

        // ---------- 1) Preferred: use pre-aggregated data ----------
        const aggPack = buildingData.occ_cls_occ_dict_sankey;
        // use POINTS (sum within each class pool) as the default
        const agg = aggPack?.by_points || aggPack?.by_buildings;


        if (agg && agg.nodes && agg.links && Array.isArray(agg.nodes) && agg.nodes.length) {
        const nodes  = agg.nodes.map(n => n.name || n.label || String(n));
        const sources = agg.links.source;
        const targets = agg.links.target;
        const values  = agg.links.value;

        // Color left-side OCC_CLS nodes consistently; links fade with same color
        const leftOccNodes = nodes
            .map((label, idx) => ({ label, idx }))
            .filter(n => n.label && n.label.endsWith('(Class)'));

        const baseColors = getPlasmaColors(leftOccNodes.length);
        const colorMap = {};
        leftOccNodes.forEach((n, i) => { colorMap[n.label] = baseColors[i]; });

        const nodeColors = nodes.map(lbl => colorMap[lbl] || '#cccccc');

        const linkColors = sources.map(si => {
            const srcName = nodes[si];
            const c = colorMap[srcName] || 'rgb(180,180,180)';
            // rgba fade
            return c.replace(')', ', 0.35)').replace('rgb', 'rgba');
        });

            // Square-root scaling for visual balancing (hover shows original)
            const scaled = values.map(v => Math.sqrt(v));

        // MODIFICATION START: Calculate correct totals for each node's tooltip
                const originalValues = values; // Keep the original link values safe
                const originalNodeTotals = Array(nodes.length).fill(0);
                
                sources.forEach((sourceIndex, i) => {
                    const targetIndex = targets[i];
                    const value = originalValues[i];
                    originalNodeTotals[sourceIndex] += value;
                    originalNodeTotals[targetIndex] += value;
                });
                // MODIFICATION END

                const sankeyData = [{
                    type: 'sankey',
                    orientation: 'h',
                    node: {
                        pad: 15,
                        thickness: 24,
                        line: { color: 'white', width: 1.5 },
                        label: nodes,
                        color: nodeColors,
                        // Use the correctly calculated node totals for the tooltip
                        customdata: originalNodeTotals,
                        hovertemplate: '<b>%{label}</b><br>Total Points: %{customdata:,}<extra></extra>'
                    },
                    link: {
                        source: sources,
                        target: targets,
                        value: scaled,
                        color: linkColors,
                        // Use the original link values for the link's tooltip
                        customdata: originalValues,
                        hovertemplate: '%{source.label} → %{target.label}<br><b>Points: %{customdata:,}</b><extra></extra>'
                    }
                }];

    // MODIFICATION START: Increase height and adjust layout for clarity
            const layout = {
                title: { text: 'OCC_CLS → NSI occtype matches', font: { size: 18, color: '#333' } },
                font: { size: 10 }, // Slightly smaller font for right-side labels
                height: 1200,       // Significantly increased height to give nodes more space
                margin: {
                    l: 150, // Add some left margin for long class names
                    r: 200  // Add right margin for the new long labels
                }
            };

            // Also, let's adjust the node padding in the sankeyData definition itself
            if (sankeyData[0] && sankeyData[0].node) {
                sankeyData[0].node.pad = 15; // Adjust vertical padding between nodes
            }
            // MODIFICATION END

            Plotly.newPlot('occClsOccDictSankey', sankeyData, layout, {responsive: true});
            return;
        }

        // ---------- 2) Fallback: compute from samples if aggregation missing ----------
        let samples = [];
        if (Array.isArray(buildingData.building_samples_balanced) && buildingData.building_samples_balanced.length) {
        samples = buildingData.building_samples_balanced;
        } else if (Array.isArray(buildingData.building_samples_random) && buildingData.building_samples_random.length) {
        samples = buildingData.building_samples_random;
        }
        if (!samples.length) {
        container.innerHTML = '<p>No aggregated data or samples available.</p>';
        return;
        }
        if (Array.isArray(samples[0])) samples = samples.flat();

        // parse "OCC_DICT": "RES: 1, COM: 0, IND: 3, ..."  → sum POSITIVE values per (OCC_CLS, occtype)
        const toInt = (v) => {
        if (typeof v === 'number') return v;
        const n = parseInt(String(v || '').replace(/[^0-9-]/g, ''), 10);
        return Number.isFinite(n) ? n : 0;
        };

        const occPoints = Object.create(null); // key: `${occ}|||${type}` -> total points (sum of values > 0)
        const occSet = new Set();
        const typeSet = new Set();

        for (const row of samples) {
        const occ = row.OCC_CLS || 'Unknown';
        occSet.add(occ);

        const dictRaw = row.OCC_DICT || '';
        const parts = String(dictRaw).split(',').map(s => s.trim()).filter(Boolean);

        for (const p of parts) {
            const m = p.match(/^([A-Z]+)\s*:\s*(-?\d+)/i);
            if (!m) continue;
            const key = m[1].toUpperCase();   // e.g. RES/COM/IND/GOV/EDU/REL/...
            const val = toInt(m[2]);

            if (val > 0) {
            typeSet.add(key);
            const k = `${occ}|||${key}`;
            occPoints[k] = (occPoints[k] || 0) + val;  // SUM points in this OCC_CLS pool
            }
        }
        }

        // build nodes and links
        const occList = [...occSet].sort();
        const typeList = [...typeSet].sort();

        const nodeLabels = [
        ...occList.map(o => `${o} (Class)`),
        ...typeList.map(t => `${t} (NSI occtype)`)
        ];
        const nodeIndex = new Map(nodeLabels.map((lbl, i) => [lbl, i]));

        const links = { source: [], target: [], value: [] };
        Object.entries(occPoints).forEach(([k, v]) => {
        const [occ, t] = k.split('|||');
        const s = nodeIndex.get(`${occ} (Class)`);
        const tIdx = nodeIndex.get(`${t} (NSI occtype)`);
        if (s != null && tIdx != null && v > 0) {
            links.source.push(s);
            links.target.push(tIdx);
            links.value.push(v);
        }
        });

        // coloring: left side class color; links use faded source color
        const baseColors = getPlasmaColors(occList.length);
        const colorMap = {};
        occList.forEach((o, i) => colorMap[`${o} (Class)`] = baseColors[i]);

        const nodeColors = nodeLabels.map(lbl => colorMap[lbl] || '#cccccc');
        const linkColors = links.source.map(si => {
        const lbl = nodeLabels[si];
        const c = colorMap[lbl] || 'rgb(180,180,180)';
        return c.replace(')', ', 0.35)').replace('rgb', 'rgba');
        });

        // optional visual scaling (square root) to reduce dominance of very large flows
        const scaled = links.value.map(v => Math.sqrt(v));

        const data = [{
        type: 'sankey',
        orientation: 'h',
        node: {
            pad: 18,
            thickness: 24,
            line: { color: 'white', width: 1.5 },
            label: nodeLabels,
            color: nodeColors,
            hovertemplate: '<b>%{label}</b><extra></extra>'
        },
        link: {
            source: links.source,
            target: links.target,
            value: scaled,
            color: linkColors,
            customdata: links.value,
            hovertemplate: '%{source.label} → %{target.label}<br><b>Points: %{customdata:,}</b><extra></extra>'
        }
        }];

        Plotly.newPlot('occClsOccDictSankey', data, {
        title: { text: 'OCC_CLS → NSI occtype matches (by points)', font: { size: 18, color: '#333' } },
        font: { size: 11 },
        height: 520
        }, {responsive: true});

        }


        
        function createDataCleaningSankey() {
            // Reads the cleaning_pipeline object from building_data.json
            const cleaningData = buildingData.data_flow_stats?.cleaning_pipeline;
            
            if (!cleaningData) {
                // If data is missing, use a fallback function
                console.warn('No cleaning pipeline data found, using fallback values');
                createFallbackDataCleaningSankey();
                return;
            }
            
            // Helper function: format numbers for display
            function formatCount(num) {
                if (num === undefined || num === null) return 'N/A'; 
                if (num >= 1000000) return `${(num / 1000000).toFixed(2)}M`;
                if (num >= 10000) return `${(num / 1000).toFixed(1)}K`;
                if (num >= 1000) return `${(num / 1000).toFixed(2)}K`;
                return num.toString();
            }
            
            // --- 1. Retrieve all variables (including new ones from the .py file) ---
            const rawData = cleaningData.initial_count;
            const invalidYear = cleaningData.invalid_year_count;
            const afterYearFilter = cleaningData.after_year_filter;
            const missingArea = cleaningData.missing_area_count;
            const afterMissingArea = cleaningData.after_missing_area;
            
            // [FIX]: Use the correct variable name as defined in the Python script
            const invalidRawHeight = cleaningData.invalid_raw_height_count || 0;
            // [NEW]: Add the second height filter defined in the Python script
            const invalidAssumedHeight = cleaningData.invalid_assumed_height_count || 0;

            const finalCleaned = cleaningData.final_count;
            
            // --- 2. Update node labels ---
            const sankeyData = [{
                type: 'sankey',
                orientation: 'h',
                node: {
                    pad: 15, thickness: 30, line: { color: 'white', width: 2 },
                    label: [
                        `Raw Data<br>(${formatCount(rawData)} records)`, // Node 0
                        `Unmatched USA Structure polygons...<br>(${formatCount(invalidYear)} removed)`, // Node 1
                        `After Year Filter (Cleaned year_built <= 0)<br>(${formatCount(afterYearFilter)} records)`, // Node 2
                        `Missing Area (Cleaned <= 0 & NaN)<br>(${formatCount(missingArea)} removed)`, // Node 3
                        `After Missing Area Filter (Cleaned <= 0 & NaN)<br>(${formatCount(afterMissingArea)} records)`, // Node 4
                        
                        // [FIX]: Node 5
                        `Invalid Raw HEIGHT (HEIGHT <= 0)<br>(${formatCount(invalidRawHeight)} removed)`,
                        // [NEW]: Node 6
                        `Invalid Assumed Height (NaN or <=0)<br>(${formatCount(invalidAssumedHeight)} removed)`,
                        
                        // Node 7 (formerly Node 5)
                        `Final Cleaned Dataset<br>(${formatCount(finalCleaned)} records)` 
                    ],
                    // --- 3. Update node colors (8 nodes total) ---
                    color: [
                        '#667eea',   // 0: Raw
                        '#E53935',   // 1: Removed (Year)
                        '#764ba2',   // 2: After Year
                        '#E53935',   // 3: Removed (Area)
                        '#bd3786',   // 4: After Area
                        '#E53935',   // 5: Removed (Raw Height) [NEW]
                        '#E53935',   // 6: Removed (Assumed Height) [NEW]
                        '#2E7D32'    // 7: Final
                    ]
                },
                // --- 4. Update links ---
                link: {
                    // The flow from Node 4 splits into 3 directions
                    source: [0, 0, 2, 2, 4, 4, 4], 
                    target: [1, 2, 3, 4, 5, 6, 7], // 4->5 (new), 4->6 (new), 4->7 (original 4->5)
                    value:  [
                        invalidYear, 
                        afterYearFilter, 
                        missingArea, 
                        afterMissingArea, 
                        
                        // [FIX]: Use the correct variable
                        invalidRawHeight, 
                        // [NEW]: Add the new value
                        invalidAssumedHeight, 
                        
                        finalCleaned
                    ],
                    color:  [
                        '#E5393540', 
                        '#764ba240', 
                        '#E5393540', 
                        '#bd378640', 

                        // [NEW]: Two new removal link colors
                        '#E5393540', // 4->5
                        '#E5393540', // 4->6
                        
                        '#2E7D3240'  // 4->7
                    ]
                }
            }];
            
            const layout = {
                title: { text: `Data Cleaning Pipeline (${cleaningData.removal_percentage}% removed)`, font: { size: 18, color: '#333' } },
                font: { size: 8 }, height: 550,
                annotations: [{
                    x: 0.5, y: -0.1, xref: 'paper', yref: 'paper',
                    text: `Total removed: ${formatCount(cleaningData.total_removed)} records`,
                    showarrow: false, font: { size: 14, color: '#666' }
                }]
            };
            
            Plotly.newPlot('dataCleaningSankey', sankeyData, layout, {responsive: true});
        }

        
        function createFallbackDataCleaningSankey() {
            // This is a fallback function in case the main data fails to provide cleaning stats.
            // It uses hardcoded placeholder data.
            console.log("Using fallback for data cleaning Sankey.");
            // (Implementation of a simple placeholder chart would go here)
            document.getElementById('dataCleaningSankey').innerHTML = '<p>Data cleaning statistics are not available.</p>';
        }
        
        function createBuildingDistributionSankey() {
        // This function creates the hierarchical Sankey diagram.
        // It supports four views, including simplified versions for both count and GFA,
        // and now includes a compact (screenshot) mode to reduce height and spacing.

        if (!buildingData || !buildingData.hierarchical_distribution) {
            console.warn('No hierarchical distribution data available');
            return;
        }

        // UI: compact (screenshot) mode toggle. If the checkbox is absent, default to true.
        const compact = document.getElementById('toggleCompact')?.checked ?? true;
        const UI = compact ? {
            NODE_PAD: 10,
            NODE_THICKNESS: 14,
            LINE_WIDTH: 1.2,
            FONT_SIZE: 10,
            TITLE_SIZE: 16,
            HEIGHT: 520,
            MARGINS: { t: 56, b: 120, l: 110, r: 110 } // keep some bottom space for annotations
        } : {
            NODE_PAD: 20,
            NODE_THICKNESS: 25,
            LINE_WIDTH: 1.5,
            FONT_SIZE: 11,
            TITLE_SIZE: 18,
            HEIGHT: 800,
            MARGINS: { t: 80, b: 200, l: 150, r: 150 }
        };

        // Get user selections from the dropdowns
        const selectedOccupancy = document.getElementById('hierarchicalOccupancy')?.value || 'all';
        const selectedView = document.getElementById('sankeyViewSelector')?.value || 'by_count';

        // Select the correct data structure based on occupancy and view selection
        let dataForOccupancy = buildingData.hierarchical_distribution[selectedOccupancy];
        if (!dataForOccupancy) {
            console.warn(`No data for occupancy: ${selectedOccupancy}`);
            document.getElementById('buildingDistributionSankey').innerHTML = '<p>No data to display for this occupancy class.</p>';
            return;
        }

        let sankeyData = dataForOccupancy[selectedView];
        if (!sankeyData || !sankeyData.nodes || !sankeyData.links || sankeyData.nodes.length === 0) {
            console.warn(`No data for view: ${selectedView}`);
            document.getElementById('buildingDistributionSankey').innerHTML = '<p>No data to display for this view (Not enough buildings to generate a flow chart).</p>';
            return;
        }

        // Helper function to format large numbers for display
        function formatSankeyNumber(num, isGfa = false) {
            if (isGfa) {
            if (num >= 1000000) return `${(num / 1000000).toFixed(1)}M`;
            if (num >= 1000) return `${Math.round(num / 1000)}K`;
            return `${Math.round(num)}`;
            }
            if (num >= 1000000) return `${(num / 1000000).toFixed(2)}M`;
            if (num >= 1000) return `${(num / 1000).toFixed(1)}K`;
            return num.toString();
        }

        // Create maps for quick node lookup by name to get their index
        const nodeIndexMap = new Map(sankeyData.nodes.map((node, i) => [node.name, i]));

        // Check if the current view is GFA-based or simplified
        const isGfaView = selectedView.includes('gfa');
        const isSimplifiedView = selectedView.includes('simplified');

        // Compute x/y positions so Plotly honors desired column and top-to-bottom order
        const maxLevel = Math.max(...sankeyData.nodes.map(n => (n.level ?? 0)));
        const nodeX = sankeyData.nodes.map(n => (n.level ?? 0) / (maxLevel || 1)); // normalized x by level

        // Group nodes by level so that we can assign y positions per column (level)
        const nodesByLevel = new Map();
        sankeyData.nodes.forEach((n, idx) => {
            const lvl = n.level ?? 0;
            if (!nodesByLevel.has(lvl)) nodesByLevel.set(lvl, []);
            nodesByLevel.get(lvl).push({ i: idx, name: n.name });
        });

        // Desired top-to-bottom orders
        const AREA_ORDER   = ['Small', 'Medium', 'Large'];
        const HEIGHT_ORDER = ['Short', 'Mid', 'High'];
        const YEAR_ORDER   = ['Historic (<1940)', 'Mid-Century (40-80)', 'Modern (>1980)'];

        // Assign y positions [0..1] to a group of nodes.
        function assignY(items, preferredOrder) {
            const ordered = [];
            preferredOrder.forEach(name => {
            const hit = items.find(d => d.name === name);
            if (hit) ordered.push(hit);
            });
            items.forEach(d => { if (!preferredOrder.includes(d.name)) ordered.push(d); });

            const n = ordered.length || 1;
            ordered.forEach((d, idx) => {
            d.y = (idx + 0.5) / n; // evenly spaced
            });
            return ordered;
        }

        const nodeY = new Array(sankeyData.nodes.length).fill(0.5); // default center
        for (const [lvl, items] of nodesByLevel.entries()) {
            const names = items.map(d => d.name);
            let arranged;
            if (AREA_ORDER.some(n => names.includes(n))) {
            arranged = assignY(items, AREA_ORDER);
            } else if (HEIGHT_ORDER.some(n => names.includes(n))) {
            arranged = assignY(items, HEIGHT_ORDER);
            } else if (YEAR_ORDER.some(n => names.includes(n))) {
            arranged = assignY(items, YEAR_ORDER);
            } else {
            arranged = assignY(items, []); // keep original order
            }
            arranged.forEach(d => { nodeY[d.i] = d.y; });
        }

        const valueUnit = isGfaView ? 'sqm' : '';
        const valueLabel = isGfaView ? 'Total GFA' : 'Count';

        // Prepare the data for Plotly
        const plotData = [{
            type: 'sankey',
            orientation: 'h',
            arrangement: 'snap',
            node: {
            pad: UI.NODE_PAD,
            thickness: UI.NODE_THICKNESS,
            line: { color: 'white', width: UI.LINE_WIDTH },
            label: sankeyData.nodes.map(n => n.name),
            color: sankeyData.nodes.map(n => plasmaColors[n.level % plasmaColors.length]),
            x: nodeX,
            y: nodeY
            },
            link: {
            source: sankeyData.links.map(link => nodeIndexMap.get(link.source)).filter(idx => idx !== undefined),
            target: sankeyData.links.map(link => nodeIndexMap.get(link.target)).filter(idx => idx !== undefined),
            value: sankeyData.links.map(link => link.value),
            color: 'rgba(102, 126, 234, 0.25)',
            hovertemplate: `%{source.label} → %{target.label}<br>${valueLabel}: %{value:,.0f} ${valueUnit}<extra></extra>`
            }
        }];

        // Dynamically set the chart title based on the selected view
        let viewTitle = '';
        if (isGfaView) {
            viewTitle = isSimplifiedView ? 'by Total GFA (Simplified)' : 'by Total GFA';
        } else {
            viewTitle = isSimplifiedView ? 'by Building Count (Simplified)' : 'by Building Count';
        }

        let title = selectedOccupancy === 'all'
            ? `MA Building Hierarchical Distribution - All Buildings (${viewTitle})`
            : `MA Building Hierarchical Distribution - ${selectedOccupancy} (${viewTitle})`;

        if (sankeyData.total_buildings) {
            title += ` (${formatSankeyNumber(sankeyData.total_buildings)} buildings)`;
        }

        // Annotations
        const annotations = [];
        if (sankeyData.bin_info) {
            let annotationText = `<b>Binning Information:</b><br>`;
            if (!isSimplifiedView) {
            annotationText += `<b>Area:</b> ${sankeyData.bin_info.Area}<br>`;
            annotationText += `<b>Height:</b> ${sankeyData.bin_info.Height}<br>`;
            }
            annotationText += `<b>Year:</b> ${sankeyData.bin_info.Year}<br>`;
            annotationText += `<b>Drainage:</b> ${sankeyData.bin_info.Drainage}`;

            annotations.push({
            x: 0.5, y: -0.25, xref: 'paper', yref: 'paper',
            text: annotationText, showarrow: false,
            font: { size: Math.max(9, UI.FONT_SIZE), color: '#555' }, align: 'center'
            });
        }

        const layout = {
            title: { text: title, font: { size: UI.TITLE_SIZE, color: '#333' } },
            font:  { size: UI.FONT_SIZE },
            height: UI.HEIGHT,
            margin: UI.MARGINS,
            annotations
        };

        Plotly.newPlot('buildingDistributionSankey', plotData, layout, { responsive: true });
        }

        function renderUnclassifiedResolution() {
        try {
            const stats = buildingData?.data_flow_stats?.unclassified_resolution;
            const section = document.getElementById('unclassifiedResolutionSection');
            if (!section) return;

            if (!stats) { section.style.display = 'none'; return; }

            // --------- Summary cards ----------
            const fmt = (v) => (typeof v === 'number' ? v.toLocaleString() : '—');
            document.getElementById('unclsTotalBefore').textContent = fmt(stats.total_unclassified_before);
            document.getElementById('unclsWithOccDict').textContent = fmt(stats.with_occdict);
            document.getElementById('unclsChanged').textContent = fmt(stats.changed);
            document.getElementById('unclsUnchanged').textContent = fmt(stats.unchanged_zero_or_unparsable);

            // --------- Breakdown table ----------
            const legend = stats?.meta?.class_legend || {R:'Residential',C:'Commercial',I:'Industrial',G:'Government',E:'Education'};
            const counts = stats.changed_to_counts || {};
            // Get all class names directly from the counts dictionary keys
            const classNames = Object.keys(counts);

            // Optional: Sort the class names, e.g., alphabetically or by count descending
            classNames.sort((a, b) => counts[b] - counts[a]); // Sort by count descending

            // Dynamically create rows for ALL classes found in the counts object
            const rows = classNames
                .map(className => `<tr><td style="padding:6px 10px;">${className}</td><td style="padding:6px 10px; text-align:right;">${fmt(counts[className])}</td></tr>`)
                .join('');
            const tableHTML = `
            <table style="width:100%; border-collapse:collapse; border:1px solid #eee;">
                <thead>
                <tr style="background:#fafafa;">
                    <th style="text-align:left; padding:8px 10px; border-bottom:1px solid #eee;">New Class</th>
                    <th style="text-align:right; padding:8px 10px; border-bottom:1px solid #eee;">Reclassified Count</th>
                </tr>
                </thead>
                <tbody>
                ${rows || `<tr><td colspan="2" style="padding:10px;">No aggregate counts (but see details below).</td></tr>`}
                </tbody>
            </table>`;
            document.getElementById('unclassifiedResolutionTable').innerHTML = tableHTML;


            const ties = stats.tie_situations_logged || {};
            const tieTableEl = document.getElementById('unclassifiedTieBreakerTable');
            const tieSectionEl = document.getElementById('unclassifiedTieBreakerSection');

            if (tieTableEl && tieSectionEl) {
                if (Object.keys(ties).length > 0) {

                    tieSectionEl.style.display = 'block'; 
                    const tie_rows = Object.entries(ties)
                        .map(([combination, count]) => 
                            `<tr>
                                <td style="padding:6px 10px;"><code>${combination}</code></td>
                                <td style="padding:6px 10px; text-align:right;">${fmt(count)}</td>
                            </tr>`
                        )
                        .join('');

                    const tieTableHTML = `
                    <table style="width:100%; border-collapse:collapse; border:1px solid #eee;">
                        <thead>
                        <tr style="background:#fafafa;">
                            <th style="text-align:left; padding:8px 10px; border-bottom:1px solid #eee;">Tie-Breaker Combination</th>
                            <th style="text-align:right; padding:8px 10px; border-bottom:1px solid #eee;">Count</th>
                        </tr>
                        </thead>
                        <tbody>
                        ${tie_rows}
                        </tbody>
                    </table>`;
                    tieTableEl.innerHTML = tieTableHTML;
                } else {

                    tieSectionEl.style.display = 'none';
                    tieTableEl.innerHTML = '';
                }
            }

            // --------- Details (full map from JSON, paginated) ----------
            const detailsSection = document.getElementById('unclassifiedDetailsSection');
            const detailsTableEl = document.getElementById('unclassifiedDetailsTable');
            const sel = document.getElementById('reclassFilter');
            const prevBtn = document.getElementById('prevPageBtn');
            const nextBtn = document.getElementById('nextPageBtn');
            const pageInfo = document.getElementById('pageInfo');

            const pairs = Array.isArray(stats.unclassified_map) ? stats.unclassified_map : [];
            if (!pairs.length) {
            detailsSection.style.display = 'none';
            return;
            }
            detailsSection.style.display = '';

            // Pagination state
            const PAGE_SIZE = 50;
            let page = 1;

            function filtered() {
            const f = sel.value || 'All';
            return (f === 'All') ? pairs : pairs.filter(p => p[1] === f);
            }

            function renderPage() {
            const data = filtered();
            const total = data.length;
            const maxPage = Math.max(1, Math.ceil(total / PAGE_SIZE));
            if (page > maxPage) page = maxPage;

            const start = (page - 1) * PAGE_SIZE;
            const slice = data.slice(start, start + PAGE_SIZE);

            const thead = `
                <thead>
                <tr style="background:#fafafa;">
                    <th style="padding:6px 8px; text-align:left;">${stats?.meta?.id_field || 'Record ID'}</th>
                    <th style="padding:6px 8px; text-align:left;">New Class</th>
                </tr>
                </thead>`;

            const tbody = slice.map(([rid, code]) => `
                <tr>
                <td style="padding:6px 8px;">${rid}</td>
                <td style="padding:6px 8px;">${legend[code] || code}</td>
                </tr>
            `).join('');

            detailsTableEl.innerHTML = `<table style="width:100%; border-collapse:collapse;">${thead}<tbody>${tbody}</tbody></table>`;
            pageInfo.textContent = `${page}/${maxPage}`;
            prevBtn.disabled = (page <= 1);
            nextBtn.disabled = (page >= maxPage);
            }

            sel.onchange = () => { page = 1; renderPage(); };
            prevBtn.onclick = () => { if (page > 1) { page--; renderPage(); } };
            nextBtn.onclick = () => { page++; renderPage(); };

            renderPage();
        } catch (e) {
            console.warn('Failed to render Unclassified Resolution section:', e);
            const section = document.getElementById('unclassifiedResolutionSection');
            if (section) section.style.display = 'none';
        }
        }

        function createYearOccSankey() {
        const containerId = 'yearOccSankey';
        const el = document.getElementById(containerId);

        // Data sources
        const flow = buildingData?.year_occ_flow?.combination_counts || null;
        const meta = buildingData?.year_occ_flow?.meta || {};
        const samples = buildingData?.building_samples_random || [];
        if (!flow && !samples.length) {
            el.innerHTML = '<p>No data available for this Sankey.</p>';
            return;
        }

        // Toggles
        const includeMaterial   = document.getElementById('toggleMaterial')?.checked ?? true;
        const includeFoundation = document.getElementById('toggleFoundation')?.checked ?? true;
        const includeSoil       = document.getElementById('toggleSoil')?.checked ?? true;

        // Metric selector: 'count' or 'gfa'
        const metric = document.getElementById('yearOccMetric')?.value || 'count';
        const isGFA  = (metric === 'gfa') && Array.isArray(flow) && flow.length > 0;

        // Compact (screenshot) mode: if toggle not present, default to true
        const compact = document.getElementById('toggleCompact')?.checked ?? true;
        const UI = compact ? {
            NODE_THICKNESS: 12,
            NODE_PAD_WANT: 10,
            FONT_SIZE: 10,
            TITLE_SIZE: 16,
            MARGIN_T: 48, MARGIN_R: 140, MARGIN_B: 32, MARGIN_L: 16,
            HEIGHT: 480,
            LINK_RGBA: 'rgba(102, 126, 234, 0.20)',
            LINE_WIDTH: 1.2
        } : {
            NODE_THICKNESS: 18,
            NODE_PAD_WANT: 18,
            FONT_SIZE: 12,
            TITLE_SIZE: 18,
            MARGIN_T: 70, MARGIN_R: 160, MARGIN_B: 40, MARGIN_L: 20,
            HEIGHT: null, // computed via sticky logic
            LINK_RGBA: 'rgba(102, 126, 234, 0.22)',
            LINE_WIDTH: 2
        };

        // Display name maps
        const MATERIAL_NAME   = { M:'Masonry', W:'Wood', H:'Manufactured', S:'Steel', C:'Concrete' };
        const FOUNDATION_NAME = { C:'Crawl Space', B:'Basement', S:'Slab', P:'Pier', I:'Pile', F:'Fill', W:'Solid Wall' };

        // Layout helpers
        function computeRightMargin(labels, fontSize = 12, padding = 28) {
            if (!labels || !labels.length) return 160;
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.font = `${fontSize}px -apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Arial`;
            const maxPx = Math.max(...labels.map(s => ctx.measureText(String(s)).width));
            return Math.max(120, Math.min(Math.ceil(maxPx) + padding, 380));
        }
        function truncateLabel(s, max = 22) {
            s = String(s ?? '');
            return s.length > max ? s.slice(0, max - 1) + '…' : s;
        }

        // Nodes / links builders
        const nodeIndex = new Map();
        const nodes = [];
        function getIndex(label) {
            if (!nodeIndex.has(label)) {
            nodeIndex.set(label, nodes.length);
            nodes.push({ name: label });
            }
            return nodeIndex.get(label);
        }
        const linkMap    = new Map();  // "A→B" -> aggregated value
        const yearCounts = new Map();  // "Y:xxx" -> aggregated value
        const pushPair = (a, b, v) => {
            if (!v || !isFinite(v)) return;
            const key = a + '→' + b;
            linkMap.set(key, (linkMap.get(key) || 0) + v);
        };

        // Column order (left -> right)
        const prefixes = ['Y:', 'O:'];
        if (includeMaterial)   prefixes.push('M:');
        if (includeFoundation) prefixes.push('F:');
        if (includeSoil)       prefixes.push('S:');

        // Build chains (flow preferred; fallback to samples)
        if (flow) {
            for (const r of flow) {
            const yearKey = `Y:${r.year_band || 'Unknown'}`;
            const chain = [
                yearKey,
                `O:${r.occupancy || 'Unknown'}`
            ];
            if (includeMaterial)   chain.push(`M:${r.material || 'Unknown'}`);
            if (includeFoundation) chain.push(`F:${r.foundation || 'Unknown'}`);
            if (includeSoil)       chain.push(`S:${r.soil || 'Unknown'}`);

            const v = isGFA ? (Number(r.gfa) || 0) : (Number(r.count) || 0);
            if (v <= 0) continue;

            yearCounts.set(chain[0], (yearCounts.get(chain[0]) || 0) + v);
            for (let i = 0; i < chain.length - 1; i++) pushPair(chain[i], chain[i + 1], v);
            }
        } else {
            // Fallback to random samples
            function yearBand(y) {
            if (!y || isNaN(y)) return 'Unknown';
            if (y > 1980) return 'Modern (>1980)';
            if (y >= 1940) return 'Mid-Century (1940–1980)';
            return 'Historic (<1940)';
            }
            for (const d of samples) {
            const chain = [
                `Y:${yearBand(d.year_built)}`,
                `O:${d.OCC_CLS || 'Unknown'}`
            ];
            if (includeMaterial)   chain.push(`M:${d.material_type || 'Unknown'}`);
            if (includeFoundation) chain.push(`F:${d.foundation_type || 'Unknown'}`);
            if (includeSoil)       chain.push(`S:${d.compname || 'Unknown'}`);

            const v = 1; // count-only for samples
            yearCounts.set(chain[0], (yearCounts.get(chain[0]) || 0) + v);
            for (let i = 0; i < chain.length - 1; i++) pushPair(chain[i], chain[i + 1], v);
            }
        }

        // Convert pairs -> arrays and add Root -> Year
        const sources = [], targets = [], values = [];
        for (const [k, v] of linkMap.entries()) {
            const [l1, l2] = k.split('→');
            sources.push(getIndex(l1));
            targets.push(getIndex(l2));
            values.push(v);
        }
        const rootLabel = 'R:All Buildings';
        const rootIndex = getIndex(rootLabel);
        for (const [yLabel, v] of yearCounts.entries()) {
            sources.push(rootIndex);
            targets.push(getIndex(yLabel));
            values.push(v);
        }

        // Human readable labels
        const displayLabels = nodes.map(n => {
            const raw = n.name;
            if (raw.startsWith('R:')) return 'All Buildings';
            if (raw.startsWith('Y:')) return raw.slice(2);
            if (raw.startsWith('O:')) return raw.slice(2);
            if (raw.startsWith('M:')) { const s = raw.slice(2); return MATERIAL_NAME[s] || s; }
            if (raw.startsWith('F:')) { const s = raw.slice(2); return FOUNDATION_NAME[s] || s; }
            if (raw.startsWith('S:')) return raw.slice(2);
            return raw;
        });
        const fullNodeLabels  = displayLabels.slice();
        const shortNodeLabels = fullNodeLabels.map(l => truncateLabel(l, 22));

        // Levels and x positions
        const prefixesInOrder = ['R:', ...prefixes];
        const prefixToLevel = Object.fromEntries(prefixesInOrder.map((p, i) => [p, i]));
        const maxLevel = prefixesInOrder.length - 1;

        const nodeX = new Array(nodes.length);
        const nodeLevel = new Array(nodes.length);
        const bucketsByLevel = new Map(); // level -> node indices
        nodes.forEach((n, i) => {
            const pref = n.name.slice(0, 2);
            const lvl  = prefixToLevel[pref] ?? 0;
            nodeLevel[i] = lvl;
            nodeX[i] = (maxLevel ? (lvl / maxLevel) : 0);
            if (!bucketsByLevel.has(lvl)) bucketsByLevel.set(lvl, []);
            bucketsByLevel.get(lvl).push(i);
        });

        // Height and padding computation
        let finalHeight, plotAreaHeight, NODE_PAD, NODE_THICKNESS;
        NODE_THICKNESS = UI.NODE_THICKNESS;

        if (compact) {
            // Fixed compact height, no sticky growth
            finalHeight = UI.HEIGHT;
            plotAreaHeight = Math.max(1, finalHeight - UI.MARGIN_T - UI.MARGIN_B);

            const counts = [];
            for (let lvl = 0; lvl <= maxLevel; lvl++) {
            const arr = bucketsByLevel.get(lvl) || [];
            counts.push(arr.length || 1);
            }
            const padPerLevel = counts.map(n => Math.max(2, (plotAreaHeight - n * NODE_THICKNESS) / (n + 1)));
            NODE_PAD = Math.min(UI.NODE_PAD_WANT, ...padPerLevel);
        } else {
            // Sticky logic (original behavior)
            const counts = [];
            for (let lvl = 0; lvl <= maxLevel; lvl++) {
            const arr = bucketsByLevel.get(lvl) || [];
            counts.push(arr.length || 1);
            }
            const requiredByLevel   = counts.map(n => n * NODE_THICKNESS + (n + 1) * UI.NODE_PAD_WANT);
            const plotHeightNeeded  = requiredByLevel.length ? Math.max(...requiredByLevel) : 0;
            const figureHeightGuess = UI.MARGIN_T + plotHeightNeeded + UI.MARGIN_B + 40;

            window.__YEAR_OCC_STICKY_HEIGHT__ = Math.max(window.__YEAR_OCC_STICKY_HEIGHT__ || 0, figureHeightGuess);
            finalHeight   = window.__YEAR_OCC_STICKY_HEIGHT__;
            plotAreaHeight = Math.max(1, finalHeight - UI.MARGIN_T - UI.MARGIN_B);

            const padPerLevel = counts.map(n => Math.max(2, (plotAreaHeight - n * NODE_THICKNESS) / (n + 1)));
            NODE_PAD = Math.min(UI.NODE_PAD_WANT, ...padPerLevel);
        }

        // Y positions
        const nodeY = new Array(nodes.length).fill(0.5);
        for (let lvl = 0; lvl <= maxLevel; lvl++) {
            const arr = bucketsByLevel.get(lvl) || [];
            const n = arr.length || 1;
            const required = n * NODE_THICKNESS + (n + 1) * NODE_PAD;
            const extra = Math.max(0, plotAreaHeight - required);
            const topOffset = (extra / 2) + NODE_PAD;
            arr.forEach((idx, k) => {
            const topPx = topOffset + k * (NODE_THICKNESS + NODE_PAD);
            nodeY[idx] = topPx / plotAreaHeight;
            });
        }

        // Explicit vertical order for Year column if provided
        const YEAR_ORDER_DISPLAY = meta.year_order_top_to_bottom || [
            'Historic (<1940)', 'Mid-Century (1940–1980)', 'Modern (>1980)'
        ];
        const yearLabelsWanted = YEAR_ORDER_DISPLAY.map(s => `Year: ${s}`);
        const labelToIdx = new Map(displayLabels.map((lab, i) => [lab, i]));
        const yearIdxOrdered = yearLabelsWanted.map(l => labelToIdx.get(l)).filter(i => i !== undefined);
        if (yearIdxOrdered.length) {
            const n = yearIdxOrdered.length;
            const required = n * NODE_THICKNESS + (n + 1) * NODE_PAD;
            const extra = Math.max(0, plotAreaHeight - required);
            const topOffset = (extra / 2) + NODE_PAD;
            yearIdxOrdered.forEach((idx, k) => {
            const topPx = topOffset + k * (NODE_THICKNESS + NODE_PAD);
            nodeY[idx] = topPx / plotAreaHeight;
            });
        }

        // Colors
        const palette = (typeof plasmaColors !== 'undefined' && Array.isArray(plasmaColors) && plasmaColors.length)
            ? plasmaColors
            : ['#0d0887','#46039f','#7201a8','#9c179e','#bd3786','#d8576b','#ed7953','#fb9f3a','#fdca26','#f0f921'];
        const nodeColors = nodeLevel.map(lvl => palette[lvl % palette.length]);

        // Title

        const isFull = !!flow;


        const dims = ['Year', 'Occupancy'];
        if (includeMaterial)   dims.push('Material');
        if (includeFoundation) dims.push('Foundation');
        if (includeSoil)       dims.push('Soil');

        const dimsTitle = dims.join(' \u2192 ');
        const titleBase  = isFull ? dimsTitle : `${dimsTitle} (Sampled)`;
        const titleText  = titleBase + (isGFA ? ' — by GFA (sqm)' : ' — by Building Count');


        try { updateYearOccSankeyTitle && updateYearOccSankeyTitle(); } catch(e) {}


        // Render
        try { Plotly.purge(containerId); } catch (e) {}

        const data = [{
            type: 'sankey',
            orientation: 'h',
            arrangement: 'snap',
            node: {
            thickness: NODE_THICKNESS,
            pad: NODE_PAD,
            line: { color: 'white', width: UI.LINE_WIDTH },
            label: shortNodeLabels,
            hovertext: fullNodeLabels,
            hoverinfo: 'text',
            x: nodeX,
            y: nodeY,
            color: nodeColors
            },
            link: {
            source: sources,
            target: targets,
            value: values,
            color: UI.LINK_RGBA,
            hovertemplate: isGFA
                ? '%{source.label} → %{target.label}<br><b>GFA:</b> %{value:,.0f} sqm<extra></extra>'
                : '%{source.label} → %{target.label}<br><b>Count:</b> %{value:,}<extra></extra>',
            valuesuffix: isGFA ? ' sqm' : '',
            valueformat: isGFA ? ',.0f' : ',d'
            }
        }];

        const rightMargin = computeRightMargin(shortNodeLabels, UI.FONT_SIZE, 24);
        const layout = {
            title: { text: titleText, font: { size: UI.TITLE_SIZE, color: '#333' } },
            font:  { size: UI.FONT_SIZE },
            margin:{ t: UI.MARGIN_T, r: Math.max(UI.MARGIN_R, rightMargin), b: UI.MARGIN_B, l: UI.MARGIN_L },
            height: compact ? UI.HEIGHT : (window.__YEAR_OCC_STICKY_HEIGHT__ || 560)
        };

        Plotly.newPlot(containerId, data, layout, {
            responsive: true,
            displaylogo: false,
            modeBarButtonsToRemove: ['lasso2d','select2d']
        });
        }

        /**
         * Sets the metric for CLF heatmaps (count or gfa) and updates the charts.
         */
        function setCLFHeatmapMetric(metric) {
            currentCLFHeatmapMetric = metric;

            document.getElementById('clfHeatmapTabCount').classList.toggle('active', metric === 'count');
            document.getElementById('clfHeatmapTabGFA').classList.toggle('active', metric === 'gfa');

            if (typeof createCLFHeatmap === 'function') {
                createCLFHeatmap();
            }
            if (typeof createCLFStructuralSystemHeatmap === 'function') {
                createCLFStructuralSystemHeatmap();
            }
        }

        function createCLFCharts() {
            if (!clfData) {
                // Safety check: If data isn't loaded, show an error and stop.
                document.getElementById('clf').innerHTML = '<p style="padding: 50px; text-align: center;">CLF data (clf_data.json) could not be loaded.</p>';
                return;
            }
            // Call the functions to draw the initial charts
            createCLFScatterPlot();
            createCLFHeatmap();
            createCLFStructuralSystemHeatmap();
            createCLFBoxPlotOverlay();
        }

        function createCLFScatterPlot() {
            if (!clfData || !clfData.scatter_data) {
                document.getElementById('clfScatterPlot').innerHTML = '<p>Scatter plot data missing.</p>';
                return;
            }
            
            // Safety check to ensure the Python preprocessing script has been updated
            if (!clfData.scatter_data.material_type) {
                document.getElementById('clfScatterPlot').innerHTML = 
                    '<p style="color: red; padding: 20px;"><b>Error:</b> `material_type` not found in `clf_data.json`.' + 
                    '<br>Please ensure `data_preprocessor.py` has been updated and re-run as instructed.</p>';
                return;
            }

            // --- 1. Prepare data and settings ---
            const data = clfData.scatter_data;
            const xSelector = document.getElementById('clfXAxis');
            const ySelector = document.getElementById('clfYAxis');
            const useLogScale = document.getElementById('clfLogToggle').checked;

            const xField = xSelector.value;
            const yField = ySelector.value;
            const xLabel = xSelector.options[xSelector.selectedIndex].text;
            const yLabel = ySelector.options[ySelector.selectedIndex].text;

            const plotData = [];
            const occColors = FIXED_OCC_COLORS; // Global color map


            // --- 2. Create OCC_CLS (color) legend, sorted by frequency ---
            
            // Count occurrences of each OCC_CLS
            const occCounts = {};
            data.OCC_CLS.forEach(occ => {
                if (occ) {
                    occCounts[occ] = (occCounts[occ] || 0) + 1;
                }
            });
            
            // Sort by count (descending)
            const sortedOccs = Object.keys(occCounts).sort((a, b) => occCounts[b] - occCounts[a]);

            // Create “dummy” legend entries for each OCC_CLS
            sortedOccs.forEach(occ => {
                plotData.push({
                    x: [null], y: [null], // No real data points
                    type: 'scatter',
                    mode: 'markers',
                    name: `${occ} (${occCounts[occ]})`, // e.g., "Commercial (8)"
                    marker: { 
                        color: occColors[occ] || '#999', 
                        symbol: 'square', // Uniform symbol for color legend
                        size: 10 
                    },
                    showlegend: true,
                    legendgroup: 'occupancy'
                });
            });

            // --- 3. Create Structural System (shape) legend using actual data ---
            
            // NEW: Define symbols for Structural Systems
            const structSysSymbolMap = {
                'Steel': 'circle',
                'Concrete': 'circle-open',
                'Steel/Concrete': 'diamond',
                'Steel/Masonry': 'square-open',
                'Wood: Mass Timber': 'square',
                'Wood: Light-frame': 'diamond-open',
                'Other': 'cross'
            };
            const defaultSymbol = 'x'; // Keep 'x' as default

            // Get unique structural systems from the data
            const structSystems = [...new Set(data.str_sys_summary)].filter(Boolean);

            structSystems.forEach((sys, i) => {
                const indices = [];
                // Find all points matching this structural system
                data.str_sys_summary.forEach((s, index) => {
                    if (s === sys) indices.push(index);
                });
                if (indices.length === 0) return;

                const xValues = indices.map(index => data[xField][index]);
                const yValues = indices.map(index => data[yField][index]);
                const occValues = indices.map(index => data.OCC_CLS[index]);
                
                // Map each point to its OCC_CLS color
                const pointColors = occValues.map(occ => occColors[occ] || '#999999');
                const structSysName = sys; // The name is the full string, e.g., "Steel"

                plotData.push({
                    x: xValues,
                    y: yValues,
                    mode: 'markers',
                    type: 'scatter',
                    name: `${structSysName} (${indices.length})`, // e.g., "Steel (10)"
                    marker: { 
                        color: pointColors,
                        symbol: structSysSymbolMap[sys] || defaultSymbol, // Use new symbol map
                        size: 9, 
                        opacity: 0.8,
                        line: { color: 'rgba(0,0,0,0.4)', width: 1 }
                    },
                    customdata: indices.map(index => ({
                        occ: data.OCC_CLS[index],
                        sys: data.str_sys_summary[index] // Add structural system to hover data
                    })),
                    hovertemplate: `<b>%{customdata.occ}</b><br>` +
                                `Struct System: %{customdata.sys}<br>` + // Updated hover text
                                `${xLabel}: %{x:,.2f}<br>` +
                                `${yLabel}: %{y:,.2f}<extra></extra>`,
                    showlegend: true,
                    legendgroup: 'struct_system' // New legend group
                });
            });

            // --- 4. Define layout ---
            const layout = {
                title: `CLF Data: ${yLabel} vs. ${xLabel} ${useLogScale ? '(Log Scale)' : '(Linear Scale)'}`,
                xaxis: { 
                    title: xLabel, 
                    type: useLogScale ? 'log' : 'linear',
                    autorange: true,
                    rangemode: useLogScale ? 'normal' : 'tozero' 
                },
                yaxis: { 
                    title: yLabel, 
                    type: useLogScale ? 'log' : 'linear',
                    autorange: true,
                    rangemode: useLogScale ? 'normal' : 'tozero'
                },
                height: 600,
                hovermode: 'closest',
                legend: {
                    title: { text: '<b>Legend</b>' },
                    tracegroupgap: 20, // Add space between legend groups
                    orientation: 'v',
                    yanchor: 'middle',
                    y: 0.5,
                    xanchor: 'left',
                    x: 1.05
                },
                margin: { r: 190 } // Extra right margin for long legend text
            };

            // --- 5. Render the plot ---
            Plotly.newPlot('clfScatterPlot', plotData, layout, {responsive: true});
        }


        /**
         * Creates the CLF materials vs. foundation heatmap.
         */
        function createCLFHeatmap() {
            const metric = currentCLFHeatmapMetric; // 'count' or 'gfa'
            const dataKey = (metric === 'gfa') ? 'heatmap_material_gfa' : 'heatmap_material_count';

            if (!clfData || !clfData[dataKey]) {
                document.getElementById('clfHeatmap').innerHTML = `<p>Heatmap data ('${dataKey}') missing.</p>`;
                return;
            }

            const hData = clfData[dataKey];

            const materialNames = hData.y.map(m => materialTypeMap[m] || m); // y-axis from python
            const foundationNames = hData.x.map(f => foundationTypeMap[f] || f); // x-axis from python

            const heatmapData = [{
                z: hData.z,
                x: foundationNames, // JS x-axis uses python's x-data (foundation)
                y: materialNames,   // JS y-axis uses python's y-data (material)
                type: 'heatmap',
                colorscale: 'Plasma',
                showscale: true,

                colorbar: { title: (metric === 'gfa') ? 'Total Est. GFA (sqm)' : 'Building Count' },
                hovertemplate: 'Foundation: %{x}<br>Material: %{y}<br>' + 
                            ((metric === 'gfa') ? 'GFA: %{z:,.0f} sqm' : 'Count: %{z}') +
                            '<extra></extra>'
            }];

            const layout = {
                title: `Mapped Material Type vs. Foundation Type (${metric === 'gfa' ? 'by GFA' : 'by Count'})`,
                xaxis: { title: 'Foundation Type' },
                yaxis: { title: 'Mapped Material Type' },
                height: 550,
                margin: { l: 150, b: 100, t: 80 }
            };

            Plotly.newPlot('clfHeatmap', heatmapData, layout, {responsive: true});
        }

        /**
         * Creates the NEW CLF structural system vs. foundation heatmap.
         * Reads 'currentCLFHeatmapMetric' to toggle between count and GFA.
         */
        function createCLFStructuralSystemHeatmap() {
       
            const metric = currentCLFHeatmapMetric; // 'count' or 'gfa'
            const dataKey = (metric === 'gfa') ? 'heatmap_struct_gfa' : 'heatmap_struct_count';

            if (!clfData || !clfData[dataKey]) {
                document.getElementById('clfStructHeatmap').innerHTML = `<p>Heatmap data ('${dataKey}') missing.</p>`;
                return;
            }

            const hData = clfData[dataKey];


            const structSystemNames = hData.y; // y-axis from python
            const foundationNames = hData.x.map(f => foundationTypeMap[f] || f); // x-axis from python

            const heatmapData = [{
                z: hData.z,
                x: foundationNames, // JS x-axis
                y: structSystemNames,   // JS y-axis
                type: 'heatmap',
                colorscale: 'Plasma',
                showscale: true,
                colorbar: { title: (metric === 'gfa') ? 'Total Est. GFA (sqm)' : 'Building Count' },
                hovertemplate: 'Foundation: %{x}<br>Struct System: %{y}<br>' + 
                            ((metric === 'gfa') ? 'GFA: %{z:,.0f} sqm' : 'Count: %{z}') +
                            '<extra></extra>'
            }];

            const layout = {
                title: `Original Structural System vs. Foundation Type (${metric === 'gfa' ? 'by GFA' : 'by Count'})`,
                xaxis: { title: 'Foundation Type' },
                yaxis: { title: 'Original Structural System' },
                height: 550,
                margin: { l: 150, b: 100, t: 80 }
            };

            Plotly.newPlot('clfStructHeatmap', heatmapData, layout, {responsive: true});
        }

        function createCLFBoxPlotOverlay() {
            const chartDiv = document.getElementById('clfBoxPlotOverlay');
            // We need both datasets for this chart
            if (!buildingData || !clfData) {
                chartDiv.innerHTML = '<p>Box plot overlay cannot be drawn. Main data or CLF data is missing.</p>';
                return;
            }

            const mainSamples = buildingData.building_samples_random; // Data for boxes
            const clfScatterData = clfData.scatter_data; // Data for 'x' markers
            const plotData = [];

            // 1. Get all unique occupancy classes from *both* datasets
            const mainOccs = new Set(mainSamples.map(d => d.OCC_CLS));
            const clfOccs = new Set(clfScatterData.OCC_CLS);
            const allOccClasses = [...new Set([...mainOccs, ...clfOccs])].filter(Boolean);
            
            // 2. Sort classes using the same fixed order as your other charts
            const occOrder = ['Residential', 'Commercial', 'Government', 'Industrial', 
                            'Assembly', 'Education', 'Utility and Misc', 'Unclassified', 'Agriculture'];
            allOccClasses.sort((a, b) => {
                const idxA = occOrder.indexOf(a);
                const idxB = occOrder.indexOf(b);
                if (idxA === -1) return 1;
                if (idxB === -1) return -1;
                return idxA - idxB;
            });

            // 3. Create Box Plot Traces (one for each class from the main dataset)
            allOccClasses.forEach(occ => {
                
                // **** START: MODIFICATION (THIS IS THE FIX) ****
                // We MUST filter for > 0, because log axes cannot handle 0, null, or negative values.
                // This prevents Plotly from incorrectly clipping the whiskers.
                const gfaValues = mainSamples
                    .filter(d => d.OCC_CLS === occ && d['Est GFA sqmeters'] > 0)
                    .map(d => d['Est GFA sqmeters']);
                // **** END: MODIFICATION ****

                plotData.push({
                    y: gfaValues.length > 0 ? gfaValues : [null], // Use [null] to force category to appear
                    name: occ,
                    type: 'box',
                    boxpoints: false, // Don't show the underlying points for the box plot
                    marker: { color: FIXED_OCC_COLORS[occ] || '#999' },
                    line: { width: 2 },
                    showlegend: true // Show these in the legend
                });
            });

            // 4. Create a SINGLE Scatter Trace for all CLF 'x' points
            // (This part remains unchanged)
            const clfXValues = []; 
            const clfYValues = []; 
            const clfHoverText = [];
            
            const clfOccData = clfScatterData.OCC_CLS;
            const clfGfaData = clfScatterData['Est GFA sqmeters'];
            
            for (let i = 0; i < clfOccData.length; i++) {
                const occ = clfOccData[i];
                if (!occ) continue; 
                
                clfXValues.push(occ); 
                clfYValues.push(clfGfaData[i]); 
                clfHoverText.push(`<b>CLF Data Point</b><br>Occupancy: ${occ}<br>GFA: ${clfGfaData[i].toFixed(0)} sqm`);
            }

            plotData.push({
                x: clfXValues,
                y: clfYValues,
                name: 'CLF Data (x)', 
                type: 'scatter',
                mode: 'markers',
                marker: { 
                    symbol: 'x',
                    color: 'black', 
                    size: 6, 
                    opacity: 0.6
                },
                xaxis: 'x',
                yaxis: 'y',
                hovertemplate: '%{text}<extra></extra>',
                text: clfHoverText,
                showlegend: true
            });

            // 5. Define Layout (This part remains unchanged, keeping our previous fix)
            const layout = {
                title: 'GFA Distribution: Main Dataset (Boxes) vs. CLF Data (x)',
                yaxis: { 
                    title: 'Est. GFA (sqm)', 
                    type: 'log',
                    range: [0, 7]  // Keep this: 10^0 (1) to 10^7 (10M)
                },
                xaxis: { 
                    title: 'Occupancy Class',
                    categoryorder: 'array', 
                    categoryarray: allOccClasses
                },
                boxmode: 'overlay', 
                height: 600,
                hovermode: 'closest',
                legend: {}
            };
            
            // 6. Render the plot
            Plotly.newPlot(chartDiv, plotData, layout, {responsive: true});
        }


        
        async function loadData() {
            try {
                console.log('Loading main data file...');
                
                // Load main data file
                const response = await fetch('building_data.json');
                if (!response.ok) {
                    throw new Error('Failed to load main data file');
                }
                
                buildingData = await response.json();

                                try {
                    console.log('Loading historic shoreline building data...');
                    const historicResponse = await fetch('historic_shoreline_buildings.json');
                    if (!historicResponse.ok) {
                        throw new Error('Failed to load historic_shoreline_buildings.json');
                    }
                    historicShorelineData = await historicResponse.json();
                    console.log(`Loaded ${historicShorelineData.length} buildings on reclaimed land.`);
                } catch (error) {
                    console.error('Could not load historic shoreline data:', error);
                    // If the file fails to load, initialize as an empty array to prevent dashboard from breaking.
                    historicShorelineData = []; 
                }

                try {
                    console.log('Loading CLF data...');
                    const clfResponse = await fetch('clf_data.json');
                    if (clfResponse.ok) {
                        clfData = await clfResponse.json(); // Store data in the global variable
                        console.log('CLF data loaded successfully.');
                    } else {
                        console.warn('Failed to load clf_data.json. CLF section will be unavailable.');
                        clfData = null; // Ensure it's null if loading fails
                    }
                } catch (error) {
                    console.error('Error loading CLF data:', error);
                    clfData = null;
                }
                
                // Store soil analysis data globally
                if (buildingData.soil_analysis) {
                    soilAnalysisData = buildingData.soil_analysis;
                    // Add compname data if not present
                    if (!soilAnalysisData.compname_stats) {
                        soilAnalysisData.compname_stats = generateCompnameStats();
                    }
                    console.log('Soil analysis data loaded');
                }
                
                // Check version and format
                const version = buildingData.metadata?.version;
                const hasSplitSamples = buildingData.metadata?.samples_split;
                
                if (hasSplitSamples && buildingData.metadata?.samples_files) {
                    console.log('Detected multi-file sample format, loading sample chunks...');
                    
                    // Initialize empty arrays for samples
                    buildingData.building_samples_random = [];
                    buildingData.building_samples_balanced = [];
                    
                    const sampleFiles = buildingData.metadata.samples_files;
                    console.log(`Loading ${sampleFiles.length} sample files...`);
                    
                    // Load all sample files
                    let loadedFiles = 0;
                    let failedFiles = 0;
                    
                    for (const fileInfo of sampleFiles) {
                        try {
                            const sampleResponse = await fetch(fileInfo.filename);
                            if (sampleResponse.ok) {
                                const sampleData = await sampleResponse.json();
                                
                                // Add samples to appropriate array
                                if (fileInfo.type === 'random') {
                                    buildingData.building_samples_random.push(...sampleData.samples);
                                } else if (fileInfo.type === 'balanced') {
                                    buildingData.building_samples_balanced.push(...sampleData.samples);
                                }
                                
                                loadedFiles++;
                                console.log(`  Loaded ${fileInfo.filename} (${fileInfo.sample_count} samples)`);
                            } else {
                                console.warn(`  Failed to load ${fileInfo.filename}`);
                                failedFiles++;
                            }
                        } catch (error) {
                            console.error(`  Error loading ${fileInfo.filename}:`, error);
                            failedFiles++;
                        }
                    }
                    
                    console.log(`Sample loading complete: ${loadedFiles}/${sampleFiles.length} files loaded`);
                    console.log(`  Random samples: ${buildingData.building_samples_random.length}`);
                    console.log(`  Balanced samples: ${buildingData.building_samples_balanced.length}`);
                    
                    // If too many files failed, create fallback samples
                    if (failedFiles > sampleFiles.length / 2) {
                        console.warn('Too many sample files failed to load, creating minimal fallback samples');
                        createFallbackSamples();
                    }
                    
                } else if (buildingData.metadata?.has_samples_file) {
                    // Version 2.0 - single samples file
                    console.log('Detected single sample file format, loading samples...');
                    
                    try {
                        const samplesResponse = await fetch('building_data_samples.json');
                        if (samplesResponse.ok) {
                            const samplesData = await samplesResponse.json();
                            buildingData.building_samples_random = samplesData.building_samples_random;
                            buildingData.building_samples_balanced = samplesData.building_samples_balanced;
                            console.log('Samples loaded successfully');
                        } else {
                            console.warn('Samples file not found, creating fallback samples');
                            createFallbackSamples();
                        }
                    } catch (error) {
                        console.error('Error loading samples:', error);
                        createFallbackSamples();
                    }
                    
                } else {
                    // Version 1.0 - samples in main file
                    console.log('Using legacy single-file format');
                    
                    if (!buildingData.building_samples_random || !buildingData.building_samples_balanced) {
                        console.warn('No samples found, creating fallback samples');
                        createFallbackSamples();
                    }
                }
                
                // Add compname to samples if not present
                if (buildingData.building_samples_random) {
                    buildingData.building_samples_random = buildingData.building_samples_random.map(s => ({
                        ...s,
                        compname: s.compname || generateRandomCompname()
                    }));
                }
                if (buildingData.building_samples_balanced) {
                    buildingData.building_samples_balanced = buildingData.building_samples_balanced.map(s => ({
                        ...s,
                        compname: s.compname || generateRandomCompname()
                    }));
                }
                
                // Process temporal data
                if (buildingData.temporal_data) {
                    buildingData.temporal_data = buildingData.temporal_data.map(d => {
                        if (d.year === 1939) {
                            d.display_year = 'pre-1940';
                        }
                        return d;
                    });
                }
                
                isDataLoaded = true;
                document.getElementById('loadingOverlay').classList.add('hidden');
                
                console.log('Data loading complete');
                console.log(`Total buildings: ${buildingData.metadata.total_buildings}`);
                console.log(`Random samples available: ${buildingData.building_samples_random?.length || 0}`);
                console.log(`Balanced samples available: ${buildingData.building_samples_balanced?.length || 0}`);
                console.log(`Soil analysis available: ${soilAnalysisData ? 'Yes' : 'No'}`);
                
                initializeDashboard();
                
            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('loadingOverlay').classList.add('hidden');
                document.getElementById('errorBox').classList.add('show');
                document.getElementById('errorMessage').textContent = error.message;
                
                // Load sample data as fallback
                console.log('Loading complete sample data as fallback...');
                loadSampleData();
            }
        }
        
        function generateCompnameStats() {
            // Generate sample compname statistics
            const compnames = [
                'Paxton', 'Charlton', 'Canton', 'Woodbridge', 'Hinckley',
                'Merrimac', 'Windsor', 'Sudbury', 'Scituate', 'Hollis'
            ];
            
            const counts = {};
            const percentages = {};
            let total = 0;
            
            compnames.forEach(name => {
                const count = Math.floor(Math.random() * 50000) + 10000;
                counts[name] = count;
                total += count;
            });
            
            compnames.forEach(name => {
                percentages[name] = (counts[name] / total * 100).toFixed(2);
            });
            
            return { counts, percentages };
        }
        
        function generateRandomCompname() {
            const compnames = [
                'Paxton', 'Charlton', 'Canton', 'Woodbridge', 'Hinckley',
                'Merrimac', 'Windsor', 'Sudbury', 'Scituate', 'Hollis'
            ];
            return compnames[Math.floor(Math.random() * compnames.length)];
        }

        function createFallbackSamples() {
            console.log('Creating empty fallback structure (no fake data)...');
            
            // Create empty arrays instead of generating fake data
            buildingData.building_samples_random = [];
            buildingData.building_samples_balanced = [];
            
            // Create minimal soil analysis structure with empty/zero values
            if (!soilAnalysisData) {
                soilAnalysisData = {
                    drainage_class_stats: {
                        counts: {},
                        percentages: {}
                    },
                    flooding_freq_stats: {
                        counts: {},
                        percentages: {}
                    },
                    water_table_stats: {
                        mean: 0,
                        median: 0,
                        std: 0,
                        min: 0,
                        max: 0,
                        q25: 0,
                        q75: 0
                    },
                    engineering_property_stats: {
                        counts: {},
                        percentages: {}
                    },
                    compname_stats: {
                        counts: {},
                        percentages: {},
                        total_unique: 0,
                        top_20_coverage: 0
                    },
                    soil_by_occupancy: {},
                    spatial_distribution: [], // Empty array for map
                    soil_risk_analysis: {
                        high_risk_count: 0,
                        high_risk_percentage: 0,
                        high_risk_by_occupancy: {},
                        high_risk_avg_year: 0,
                        high_risk_total_area: 0
                    }
                };
                
                buildingData.soil_analysis = soilAnalysisData;
            }
            
            console.log('Fallback structure created with empty data');
            console.log('Random samples: 0');
            console.log('Balanced samples: 0');
            console.log('Spatial distribution points: 0');
        }


        
        function loadSampleData() {
            console.log('Loading empty data structure as fallback...');
            buildingData = generateSampleData(); 
            soilAnalysisData = buildingData.soil_analysis;
            isDataLoaded = true;
            
                
            document.getElementById('errorBox').classList.add('show');
            document.getElementById('errorMessage').textContent = 
                'Data files could not be loaded. Dashboard is showing empty state.';
            
            initializeDashboard();
        }
             
        function initializeDashboard() {
            if (!isDataLoaded || !buildingData) {
                console.error('Data not loaded');
                return;
            }
            
            updateStatistics();
            updateOverview();
            populateOverviewFilters();
            createOverviewMap();
            createDataPipelinesDiagrams();
            renderUnclassifiedResolution();
            updateClustering();
            updateTemporalChart();
            updatePre1940Charts();
            updatePost1940();
            updateOccupancyClustering();
            updateMaterialsHeatmap();
            updateSoilAnalysis();
            updateInteractiveExplorer();
            createMixScPieChart();
            populateHistoricShorelineFilters();
            updateHistoricShorelineCharts();
            if (clfData) {
                createCLFCharts();
            }
        }

        function generateSampleData() {
            console.log('Generating empty data structure (no fake samples)...');
            
            // Define empty arrays - no fake data generation
            const occupancyClasses = [];
            const temporalData = [];
            const buildingSamples = [];
            
            // Empty soil analysis structure
            const soilAnalysis = {
                drainage_class_stats: {
                    counts: {},
                    percentages: {}
                },
                flooding_freq_stats: {
                    counts: {},
                    percentages: {}
                },
                water_table_stats: {
                    mean: 0,
                    median: 0,
                    std: 0,
                    min: 0,
                    max: 0,
                    q25: 0,
                    q75: 0
                },
                engineering_property_stats: {
                    counts: {},
                    percentages: {}
                },
                compname_stats: {
                    counts: {},
                    percentages: {},
                    total_unique: 0,
                    top_20_coverage: 0
                },
                soil_by_occupancy: {},
                spatial_distribution: [],  // Empty array for map
                soil_risk_analysis: {
                    high_risk_count: 0,
                    high_risk_percentage: 0,
                    high_risk_by_occupancy: {},
                    high_risk_avg_year: 0,
                    high_risk_total_area: 0
                }
            };
            
            // Empty occupancy clusters enhanced
            const occupancyClustersEnhanced = {};
            
            // Empty summary stats
            const summaryStats = {
                total_buildings: 0,
                avg_year_built: 0,
                avg_area_sqm: 0,
                min_year: 1900,
                max_year: 2024,
                occupancy_classes: []
            };
            
            // Empty occupancy counts
            const overviewOccupancyCounts = {};
            
            // Return the complete empty structure
            return {
                metadata: {
                    total_buildings: 0,
                    date_processed: new Date().toISOString(),
                    source_file: 'no_data_available',
                    version: '3.1'
                },
                summary_stats: summaryStats,
                overview_occupancy_counts: overviewOccupancyCounts,
                clustering: {
                    elbow_k_values: [],
                    elbow_wcss_values: [],
                    clusters: []
                },
                temporal_data: temporalData,
                pre1940: {
                    total_count: 0,
                    occupancy_counts: {},
                    residential_count: 0,
                    non_residential_count: 0,
                    percentage_of_total: 0
                },
                post1940: {},
                occupancy_clusters: {},
                occupancy_clusters_enhanced: occupancyClustersEnhanced,
                materials_foundation: {
                    all: {
                        matrix: [],
                        area_matrix: [],
                        materials: [],
                        foundations: [],
                        occupancy_breakdown: {}
                    },
                    pre1940: {
                        matrix: [],
                        area_matrix: [],
                        materials: [],
                        foundations: [],
                        occupancy_breakdown: {}
                    },
                    post1940: {
                        matrix: [],
                        area_matrix: [],
                        materials: [],
                        foundations: [],
                        occupancy_breakdown: {}
                    }
                },
                soil_analysis: soilAnalysis,
                building_samples_random: buildingSamples,  // Empty array
                building_samples_balanced: buildingSamples,  // Empty array
                hierarchical_distribution: {},
                occupancy_hierarchy_sankey: {
                    nodes: [],
                    links: { 
                        source: [], 
                        target: [], 
                        value: [] 
                    }
                },
                data_flow_stats: {
                    initial_count: 0,
                    cleaning_pipeline: {
                        initial_count: 0,
                        invalid_year_count: 0,
                        after_year_filter: 0,
                        missing_area_count: 0,
                        after_missing_area: 0,
                        missing_occ_count: 0,
                        after_missing_occ: 0,
                        area_outliers_count: 0,
                        after_outlier_removal: 0,
                        final_count: 0,
                        total_removed: 0,
                        removal_percentage: 0,
                        invalid_year_details: {
                            negative_or_zero: 0,
                            nan_values: 0
                        }
                    }
                },
                nsi_data_sources: {
                    methodology: 'NSI Dataset Construction',
                    note: 'No data available'
                }
            };
        }
        
        function updateStatistics() {
            if (!buildingData) return;
            
            const stats = buildingData.summary_stats;
            const pre1940 = buildingData.pre1940;
            
            const formatNumber = (num) => {
                if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
                if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
                return num.toString();
            };
            
            document.getElementById('totalBuildings').textContent = formatNumber(stats.total_buildings);
            document.getElementById('avgYear').textContent = Math.round(stats.avg_year_built).toString();
            document.getElementById('avgArea').textContent = Math.round(stats.avg_area_sqm) + ' m²';
            document.getElementById('numClusters').textContent = currentClusterK.toString();
            
            document.getElementById('pre1940Count').textContent = formatNumber(pre1940.total_count);
            document.getElementById('pre1940Percent').textContent = pre1940.percentage_of_total + '%';
            document.getElementById('pre1940Residential').textContent = formatNumber(pre1940.residential_count);
            document.getElementById('pre1940NonRes').textContent = formatNumber(pre1940.non_residential_count);
            
            // Update soil statistics if available
            if (soilAnalysisData) {
                document.getElementById('highRiskBuildings').textContent = formatNumber(soilAnalysisData.soil_risk_analysis?.high_risk_count || 0);
                document.getElementById('avgWaterTable').textContent = Math.round(soilAnalysisData.water_table_stats?.mean || 0).toString();
                
                // Count poor drainage sites
                const poorDrainageCount = (soilAnalysisData.drainage_class_stats?.counts?.['Poorly drained'] || 0) +
                                         (soilAnalysisData.drainage_class_stats?.counts?.['Very poorly drained'] || 0);
                document.getElementById('poorDrainageCount').textContent = formatNumber(poorDrainageCount);
                
                // Count flood risk buildings
                const floodRiskCount = (soilAnalysisData.flooding_freq_stats?.counts?.['Occasional'] || 0) +
                                      (soilAnalysisData.flooding_freq_stats?.counts?.['High'] || 0);
                document.getElementById('floodRiskCount').textContent = formatNumber(floodRiskCount);
            }
        }
        
        function showSection(sectionId) {
            const sections = document.querySelectorAll('.section');
            sections.forEach(section => section.classList.remove('active'));
            
            document.getElementById(sectionId).classList.add('active');
            
            const tabs = document.querySelectorAll('.nav-tab');
            tabs.forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');
            
            // Special handling for soil analysis tab
            if (sectionId === 'soilAnalysis') {
                event.target.classList.add('soil-tab');
            }
            
            window.dispatchEvent(new Event('resize'));
        }
        
        // MODIFIED: Soil Analysis Functions with compname support
        function updateSoilAnalysis() {
            if (!soilAnalysisData) {
                console.warn('No soil analysis data available');
                return;
            }
            
            const analysisType = document.getElementById('soilAnalysisType').value;
            
            // Update distribution chart based on analysis type
            updateSoilDistributionChart(analysisType);
            
            // Update occupancy-based soil analysis
            updateSoilByOccupancyChart(analysisType);
            
            // Update soil map
            updateSoilMap();
            
            // Update water table histogram
            updateWaterTableHistogram();
        }
        
        function updateSoilDistributionChart(analysisType) {
            let data, title, colors;
            
            switch(analysisType) {
                case 'drainage':
                    data = soilAnalysisData.drainage_class_stats;
                    title = 'Buildings by Drainage Class';
                    colors = Object.values(soilColors.drainage);
                    break;
                case 'flooding':
                    data = soilAnalysisData.flooding_freq_stats;
                    title = 'Buildings by Flooding Frequency';
                    colors = Object.values(soilColors.flooding);
                    break;
                case 'engineering':
                    data = soilAnalysisData.engineering_property_stats;
                    title = 'Buildings by Engineering Properties';
                    colors = Object.values(soilColors.engineering);
                    break;
                case 'compname':
                    // NEW: Handle compname distribution
                    data = soilAnalysisData.compname_stats;
                    title = 'Buildings by Soil Component Name';
                    colors = getPlasmaColors(10);
                    break;
                case 'risk':
                    updateRiskAssessmentChart();
                    return;
            }
            
            if (!data || !data.counts) {
                console.warn('No data available for', analysisType);
                return;
            }
            
            const sortedData = Object.entries(data.counts).sort((a, b) => b[1] - a[1]).slice(0, 15);
            
            const barData = [{
                x: sortedData.map(([k, v]) => {
                    if (analysisType === 'drainage') {
                        return k.replace(' drained', '')
                                .replace('Excessively', 'Excessive')
                                .replace('Moderately well', 'Moderate')
                                .replace('Somewhat excessively', 'Somewhat');
                    }
                    return k;
                }),
                y: sortedData.map(([k, v]) => v),
                type: 'bar',
                marker: {
                    color: sortedData.map(([k, v], i) => {
                        if (analysisType === 'drainage') return soilColors.drainage[k] || '#888';
                        if (analysisType === 'flooding') return soilColors.flooding[k] || '#888';
                        if (analysisType === 'engineering') return soilColors.engineering[k] || '#888';
                        return colors[i % colors.length];
                    }),
                    line: {
                        color: 'white',
                        width: 1
                    }
                },
                text: sortedData.map(([k, v]) => `${(data.percentages[k] || 0).toFixed(1)}%`),
                textposition: 'outside',
                hovertemplate: '%{x}<br>Count: %{y:,}<br>%{text}<extra></extra>'
            }];
            
            const layout = {
                title: {
                    text: title,
                    font: { size: 20, color: '#333' }
                },
                xaxis: { 
                    title: analysisType === 'compname' ? 'Soil Component Name' : 
                           analysisType.charAt(0).toUpperCase() + analysisType.slice(1) + ' Category',
                    tickangle: -45
                },
                yaxis: { 
                    title: 'Number of Buildings'
                },
                height: 450,
                margin: { t: 80 },
                showlegend: false
            };
            
            Plotly.newPlot('soilDistributionChart', barData, layout, {responsive: true});
        }
        
        function updateRiskAssessmentChart() {
            const riskData = soilAnalysisData.soil_risk_analysis;
            
            if (!riskData) {
                console.warn('No risk assessment data available');
                return;
            }
            
            // Create pie chart of risk distribution
            const pieData = [{
                values: [riskData.high_risk_count, buildingData.metadata.total_buildings - riskData.high_risk_count],
                labels: ['High Risk', 'Low/Moderate Risk'],
                type: 'pie',
                hole: 0.4,
                marker: {
                    colors: ['#E53935', '#2E7D32']
                },
                textinfo: 'label+percent',
                hovertemplate: '%{label}<br>Count: %{value:,}<br>%{percent}<extra></extra>'
            }];
            
            const layout = {
                title: {
                    text: 'Building Risk Assessment',
                    font: { size: 20, color: '#333' }
                },
                height: 450,
                annotations: [
                    {
                        x: 0.5,
                        y: 0.5,
                        xref: 'paper',
                        yref: 'paper',
                        text: `${riskData.high_risk_percentage}%<br>High Risk`,
                        showarrow: false,
                        font: {
                            size: 20,
                            color: '#E53935'
                        }
                    }
                ]
            };
            
            Plotly.newPlot('soilDistributionChart', pieData, layout, {responsive: true});
        }
        
        function updateSoilByOccupancyChart(analysisType) {
            if (analysisType === 'risk' || analysisType === 'compname') {
                document.getElementById('soilByOccupancyChart').innerHTML = '';
                return;
            }
            
            if (!soilAnalysisData || !soilAnalysisData.soil_by_occupancy) {
                console.warn('No occupancy-based soil data available');
                return;
            }
            
            const occupancies = ['Residential', 'Commercial', 'Industrial', 'Agriculture', 
                               'Government', 'Assembly', 'Education', 'Utility and Misc', 'Unclassified']; 
            const categories = analysisType === 'drainage' ? 
                            ['Well drained', 'Moderately well drained', 'Poorly drained', 'Very poorly drained', 'Somewhat excessively drained', 'Excessively drained'] :
                            analysisType === 'flooding' ?
                            ['Low', 'Moderate', 'High'] :
                            ['Favorable', 'Fair', 'Poor', 'Very poor'];
            
            const traces = categories.map((cat, i) => ({
                x: occupancies,
                y: occupancies.map(occ => {
                    const dataField = analysisType === 'drainage' ? 'drainage_distribution' :
                                    analysisType === 'flooding' ? 'flooding_distribution' :
                                    'engineering_distribution';
                    return soilAnalysisData.soil_by_occupancy[occ]?.[dataField]?.[cat] || 0;
                }),
                name: cat,
                type: 'bar',
                marker: {
                    color: plasmaColors[i % plasmaColors.length]
                }
            }));
            
            const layout = {
                title: {
                    text: `${analysisType.charAt(0).toUpperCase() + analysisType.slice(1)} by Occupancy Class`,
                    font: { size: 20, color: '#333' }
                },
                xaxis: { title: 'Occupancy Class' },
                yaxis: { title: 'Number of Buildings' },
                barmode: 'stack',
                height: 450
            };
            
            Plotly.newPlot('soilByOccupancyChart', traces, layout, {responsive: true});
        }
        
        // MODIFIED: updateSoilMap to include compname in tooltips
        function updateSoilMap() {
            if (!soilAnalysisData || !soilAnalysisData.spatial_distribution) {
                console.warn('No spatial distribution data available');
                return;
            }
            
            const showRiskOverlay = document.getElementById('showRiskOverlay').checked;
            const mapData = soilAnalysisData.spatial_distribution;
            
            // Now using up to 50,000 samples from the Python export
            console.log(`Soil map using ${mapData.length} samples`);
            
            // Create scatter mapbox
            const scatterData = [{
                type: 'scattermapbox',
                mode: 'markers',
                lon: mapData.map(d => d.lon),
                lat: mapData.map(d => d.lat),
                marker: {
                    size: 8,
                    color: mapData.map(d => {
                        if (showRiskOverlay) {
                            // Color by risk level
                            const isHighRisk = (d.drainage === 'Poorly drained' || 
                                              d.drainage === 'Very poorly drained' ||
                                              d.flooding === 'Frequent' || 
                                              d.flooding === 'Occasional');
                            return isHighRisk ? '#E53935' : '#2E7D32';
                        } else {
                            // Color by drainage class
                            return soilColors.drainage[d.drainage] || '#888';
                        }
                    }),
                    opacity: 0.6
                },
                text: mapData.map(d => 
                    `${d.occupancy}<br>` +
                    `Year: ${d.year_built}<br>` +
                    `Area: ${Math.round(d.area)} sqm<br>` +
                    `Drainage: ${d.drainage || 'N/A'}<br>` +
                    `Flooding: ${d.flooding || 'N/A'}<br>` +
                    `Soil Type: ${d.compname || 'Unknown'}`  // NEW: Added compname
                ),
                hovertemplate: '%{text}<extra></extra>'
            }];
            
            const layout = {
                title: {
                    text: showRiskOverlay ? 
                        `Building Risk Map (With ${mapData.length.toLocaleString()} Samples)` :  // Updated title
                        `Soil Drainage Map (With ${mapData.length.toLocaleString()} Samples)`,  // Updated title
                    font: { size: 20, color: '#333' }
                },
                mapbox: {
                    style: 'open-street-map',
                    center: { lat: 42.3601, lon: -71.0589 },
                    zoom: 8
                },
                height: 600,
                margin: { t: 50, b: 0, l: 0, r: 0 }
            };
            
            Plotly.newPlot('soilMap', scatterData, layout, {responsive: true});
        }
        
        function updateWaterTableHistogram() {
            if (!soilAnalysisData || !soilAnalysisData.water_table_stats) {
                console.warn('No water table data available');
                return;
            }
            
            const stats = soilAnalysisData.water_table_stats;
            
            const sampleData = soilAnalysisData.spatial_distribution
                .map(d => d.water_table)
                .filter(val => val !== undefined && val !== null && val > 0);
            
            if (sampleData.length === 0) {
                document.getElementById('waterTableHistogram').innerHTML = 
                    '<p style="text-align:center; padding:50px;">Insufficient valid water table data</p>';
                return;
            }
            
            const validMean = sampleData.reduce((a, b) => a + b, 0) / sampleData.length;
            
            const histData = [{
                x: sampleData,
                type: 'histogram',
                nbinsx: 30,
                marker: {
                    color: '#4169E1',
                    line: {
                        color: 'white',
                        width: 1
                    }
                },
                hovertemplate: 'Depth Range: %{x}<br>Count: %{y}<extra></extra>'
            }];
            
            const layout = {
                title: {
                    text: `Water Table Depth Distribution (${sampleData.length} valid samples, ${(sampleData.length/soilAnalysisData.spatial_distribution.length*100).toFixed(1)}% of sample)`,
                    font: { size: 20, color: '#333' }
                },
                xaxis: { 
                    title: 'Water Table Depth (cm)',
                    range: [0, 300]
                },
                yaxis: { 
                    title: 'Number of Buildings'
                },
                height: 400,
                shapes: [
                    {
                        type: 'line',
                        x0: validMean,
                        x1: validMean,
                        y0: 0,
                        y1: 1,
                        yref: 'paper',
                        line: {
                            color: 'red',
                            width: 2,
                            dash: 'dash'
                        }
                    }
                ],
                annotations: [
                    {
                        x: validMean,
                        y: 1,
                        yref: 'paper',
                        text: `Mean: ${validMean.toFixed(1)} cm (valid data only)`,
                        showarrow: true,
                        arrowhead: 2,
                        ax: 30,
                        ay: -30
                    }
                ]
            };
            
            Plotly.newPlot('waterTableHistogram', histData, layout, {responsive: true});
        }
        

        const dataSourceColumns = {
            'USA Structures': {
                color: '#667eea',
                icon: '🏢',
                description: 'Original building footprint and property data',
                columns: [
                    'Shape_Length', 'Shape_Area','BUILD_ID', 'OCC_CLS', 'PRIM_OCC', 'SEC_OCC', 'PROP_ADDR', 
                    'PROP_CITY', 'PROP_ST', 'PROP_ZIP', 'OUTBLDG', 'HEIGHT', 
                    'SQMETERS', 'SQFEET', 'H_ADJ_ELEV', 'L_ADJ_ELEV', 'FIPS', 
                    'CENSUSCODE', 'PROD_DATE', 'SOURCE', 'USNG', 'LONGITUDE', 
                    'LATITUDE', 'IMAGE_NAME', 'IMAGE_DATE', 'VAL_METHOD', 'REMARKS', 
                    'UUID', 'Est GWP kgCO2e', 'GWP Intensity', 'GWP class', 
                    'Est GFA sqft', 'Est GFA sqmeters','PRED_HEIGHT','OCC_CONFLICT','conflict_type','OCC_DICT',
                    'MIX_SC','general_fnd_type','Assumed Height'
                ]
            },
            'NSI': {
                color: '#764ba2',
                icon: '📊',
                description: 'National Structure Inventory enhancement data',
                columns: [
                     'year_built', 'material_type', 
                    'material_type_desc', 'foundation_type', 'match_type', 
                    'match_method', 'nsi_num_story', 'structure_value', 
                    'nsi_sqft', 'nsi_unit_count','nsi_occtype'
                ]
            },
            'Web Soil Survey': {
                color: '#f5576c',
                icon: '🌍',
                description: 'Soil properties and engineering characteristics',
                columns: [
                     'AREASYMBOL', 'SPATIALVER', 'MUSYM', 'MUKEY', 
                    'mukey', 'comppct_r', 'compname', 'drainagecl', 'wtdepannmin', 
                    'flodfreqcl', 'cokey', 'eng_property'
                ]
            },
            'Boston Approved Permit Dataset*': {
                color: '#009688', // Teal color matching the CSS
                icon: '👷‍♂️',
                description: 'Demolition permit data for Boston',
                columns: ['DEMOLITION_TYPE', 'DEMOLITION_DATE']
            }
        };
        


        

        function updateOverview() {
            if (!buildingData) return;
            
            createDataSourcesFlowchart();
            
            let occupancyCounts;
            if (buildingData.overview_occupancy_counts) {
                occupancyCounts = buildingData.overview_occupancy_counts;
            } else {
                occupancyCounts = {};
                buildingData.temporal_data.forEach(d => {
                    if (!occupancyCounts[d.occupancy]) {
                        occupancyCounts[d.occupancy] = 0;
                    }
                    occupancyCounts[d.occupancy] += d.count;
                });
            }
            
            const total = Object.values(occupancyCounts).reduce((a, b) => a + b, 0);
            const pieValues = Object.values(occupancyCounts);
            const pieLabels = Object.keys(occupancyCounts);

            const textArray = pieLabels.map((label, i) => {
                const percentage = (pieValues[i] / total * 100);
                
                if (percentage > 10) {
                    return `${label}<br>${percentage.toFixed(1)}%`;
                } else if (percentage > 5) {
                    return `${percentage.toFixed(1)}%`;
                } else if (percentage > 2) {
                    return `${percentage.toFixed(0)}%`;
                } else {
                    return '';
                }
            });

            const pieData = [{
                values: pieValues,
                labels: pieLabels,
                type: 'pie',
                hole: 0.4,
                marker: {
                    colors: plasmaColors
                },
                text: textArray,
                textinfo: 'text',
                textposition: 'auto',
                textfont: {
                    size: 12,
                    color: 'white'
                },
                insidetextorientation: 'radial',
                hovertemplate: '%{label}<br>Count: %{value:,}<br>%{percent}<extra></extra>',
                showlegend: true
            }];
            
            const pieLayout = {
                title: {
                    text: 'All Buildings Distribution by Occupancy Class',
                    font: { size: 20, color: '#333' }
                },
                height: 500,
                font: { size: 14 },
                showlegend: true,
                legend: {
                    orientation: 'v',
                    yanchor: 'middle',
                    y: 0.5,
                    xanchor: 'left',
                    x: 1.05
                }
            };
            
            Plotly.newPlot('overviewChart', pieData, pieLayout, {responsive: true});
            
            const timelineData = [];
            const yearCounts = {};
            
            buildingData.temporal_data.forEach(d => {
                const displayKey = d.year < 1940 ? 'pre-1940' : d.year.toString();
                if (!yearCounts[displayKey]) yearCounts[displayKey] = 0;
                yearCounts[displayKey] += d.count;
            });
            
            const years = Object.keys(yearCounts).sort((a, b) => {
                if (a === 'pre-1940') return -1;
                if (b === 'pre-1940') return 1;
                return parseInt(a) - parseInt(b);
            });
            const counts = years.map(y => yearCounts[y]);
            
            timelineData.push({
                x: years,
                y: counts,
                type: 'scatter',
                mode: 'lines',
                fill: 'tozeroy',
                line: {
                    color: plasmaColors[4],
                    width: 2
                },
                fillcolor: 'rgba(189, 55, 134, 0.2)',
                hovertemplate: 'Year: %{x}<br>Buildings: %{y:,}<extra></extra>'
            });
            
            const tickvals = years.filter((y, i) => {
                if (y === 'pre-1940') return false;
                const year = parseInt(y);
                return year % 10 === 0;
            });
            
            const timelineLayout = {
                title: {
                    text: 'Building Construction Timeline',
                    font: { size: 20, color: '#333' }
                },
                xaxis: { 
                    title: 'Year',
                    rangeslider: { visible: true },
                    type: 'category',
                    tickmode: 'array',
                    tickvals: tickvals,
                    ticktext: tickvals
                },
                yaxis: { 
                    title: 'Number of Buildings',
                    fixedrange: false
                },
                height: 400,
                hovermode: 'x unified'
            };
            
            Plotly.newPlot('overviewTimelineChart', timelineData, timelineLayout, {responsive: true});
        }

        function populateOverviewFilters() {
            if (!buildingData || !buildingData.building_samples_random) return;

            const samples = buildingData.building_samples_random;
            
            // Get unique values for each category
            const occClasses = ['All', ...new Set(samples.map(s => s.OCC_CLS).filter(Boolean))];
            const materials = ['All', ...new Set(samples.map(s => s.material_type).filter(Boolean))];
            const foundations = ['All', ...new Set(samples.map(s => s.foundation_type).filter(Boolean))];

            // Helper function to populate a select dropdown
            const populate = (selectId, options, map = null) => {
                const select = document.getElementById(selectId);
                select.innerHTML = options.map(opt => {
                    const label = map && map[opt] ? `${opt} - ${map[opt]}` : opt;
                    const value = opt === 'All' ? 'All' : opt;
                    return `<option value="${value}">${label}</option>`;
                }).join('');
            };
            
            // Populate the dropdowns
            populate('overviewOccFilter', occClasses);
            populate('overviewMaterialFilter', materials, materialTypeMap);
            populate('overviewFoundationFilter', foundations, foundationTypeMap);
        }

        // Define fixed color mapping for OCC_CLS using plasma gradient from dark to light
        const FIXED_OCC_COLORS = {
            'Residential': '#0d0887',      // Darkest purple
            'Commercial': '#46039f',       // Deep blue-purple  
            'Government': '#7201a8',       // Purple
            'Industrial': '#9c179e',       // Pink-purple
            'Assembly': '#bd3786',         // Magenta
            'Unclassified': '#d8576b',     // Rose
            'Education': '#ed7953',        // Orange
            'Utility and Misc': '#fb9f3a', // Light orange
            'Agriculture': '#f0f921'       // Brightest yellow
        };


        // Fixed colors for materials (dark to light as specified)
        const FIXED_MATERIAL_COLORS = {
            'W': '#0d0887',  // Wood - Darkest purple
            'M': '#46039f',  // Masonry - Deep blue-purple
            'S': '#7201a8',  // Steel - Purple
            'C': '#bd3786',  // Concrete - Magenta
            'H': '#f0f921'   // Manufactured - Brightest yellow
        };

        // Fixed colors for foundations (dark to light as specified)
        const FIXED_FOUNDATION_COLORS = {
            'B': '#0d0887',  // Basement - Darkest purple
            'S': '#46039f',  // Slab - Deep blue-purple
            'C': '#7201a8',  // Crawl Space - Purple
            'I': '#9c179e',  // Pile - Pink-purple
            'P': '#bd3786',  // Pier - Magenta
            'W': '#ed7953',  // Solid Wall - Orange
            'F': '#f0f921'   // Fill - Brightest yellow
        };

        function createOverviewMap() {
            // Get current filter values
            const occFilter = document.getElementById('overviewOccFilter').value;
            const materialFilter = document.getElementById('overviewMaterialFilter').value;
            const foundationFilter = document.getElementById('overviewFoundationFilter').value;
            const colorBy = document.getElementById('overviewColorBy').value;

            // Filter the data
            let filteredData = buildingData.building_samples_random.filter(d => {
                const occMatch = (occFilter === 'All' || d.OCC_CLS === occFilter);
                const materialMatch = (materialFilter === 'All' || d.material_type === materialFilter);
                const foundationMatch = (foundationFilter === 'All' || d.foundation_type === foundationFilter);
                return d.LATITUDE && d.LONGITUDE && occMatch && materialMatch && foundationMatch;
            });

            // MODIFIED: Increased limit to 75,000
            if (filteredData.length > 75000) {
                filteredData = filteredData.sort(() => 0.5 - Math.random()).slice(0, 75000);
            }

            if (filteredData.length === 0) {
                document.getElementById('overviewMapPlot').innerHTML = '<p style="text-align:center; padding-top:100px;">No data available for the current filter selection.</p>';
                return;
            }
            
            // Choose the appropriate fixed color mapping
            let colorMap;
            if (colorBy === 'OCC_CLS') {
                colorMap = FIXED_OCC_COLORS;
            } else if (colorBy === 'material_type') {
                colorMap = FIXED_MATERIAL_COLORS;
            } else if (colorBy === 'foundation_type') {
                colorMap = FIXED_FOUNDATION_COLORS;
            }
            
            // Get unique categories present in filtered data
            const colorValues = filteredData.map(d => d[colorBy]);
            const uniqueCategories = [...new Set(colorValues)].filter(cat => cat != null);
            
            if (colorBy === 'OCC_CLS') {
                const occOrder = ['Residential', 'Commercial', 'Government', 'Industrial', 
                                'Assembly', 'Unclassified', 'Education', 'Utility and Misc', 'Agriculture'];
                uniqueCategories.sort((a, b) => occOrder.indexOf(a) - occOrder.indexOf(b));
            } else if (colorBy === 'material_type') {
                const materialOrder = ['W', 'M', 'S', 'C', 'H'];  // Wood -> Masonry -> Steel -> Concrete -> Manufactured
                uniqueCategories.sort((a, b) => materialOrder.indexOf(a) - materialOrder.indexOf(b));
            } else if (colorBy === 'foundation_type') {
                const foundationOrder = ['B', 'S', 'C', 'I', 'P', 'W', 'F'];  // Basement -> Slab -> Crawl -> Pile -> Pier -> Solid Wall -> Fill
                uniqueCategories.sort((a, b) => foundationOrder.indexOf(a) - foundationOrder.indexOf(b));
            } else {
                uniqueCategories.sort();
            }
            
            // Create legend traces for categories present in filtered data
            const legendTraces = uniqueCategories.map(cat => ({
                type: 'scattermapbox',
                lon: [null],
                lat: [null],
                mode: 'markers',
                marker: {
                    size: 10,
                    color: colorMap[cat] || '#999999'  // Fallback gray for unmapped categories
                },
                name: colorBy === 'material_type' ? (materialTypeMap[cat] || cat) :
                    colorBy === 'foundation_type' ? (foundationTypeMap[cat] || cat) :
                    cat,
                showlegend: true,
                hoverinfo: 'skip'
            }));
            
            // Main map trace
            const mainTrace = {
                type: 'scattermapbox',
                lon: filteredData.map(d => d.LONGITUDE),
                lat: filteredData.map(d => d.LATITUDE),
                mode: 'markers',
                marker: {
                    size: 10,
                    color: colorValues.map(v => colorMap[v] || '#999999'),
                    opacity: 0.8,
                    line: {
                        width: 0.5,
                        color: 'rgba(255,255,255,0.3)'
                    }
                },
                text: filteredData.map(d => 
                    `<b>Year Built:</b> ${d.year_built}<br>` +
                    `<b>Occupancy:</b> ${d.OCC_CLS || 'N/A'}<br>` +
                    `<b>Material:</b> ${materialTypeMap[d.material_type] || d.material_type || 'N/A'}<br>` +
                    `<b>Foundation:</b> ${foundationTypeMap[d.foundation_type] || d.foundation_type || 'N/A'}`
                ),
                hovertemplate: '%{text}<extra></extra>',
                showlegend: false
            };
            
            const mapData = [mainTrace, ...legendTraces];
            
            const layout = {
                title: {
                    text: `Massachusetts Building Distribution (${filteredData.length} points shown)`,  // Will show up to 50k
                    font: { size: 20, color: '#333' }
                },
                mapbox: {
                    style: 'open-street-map',
                    center: { lat: 42.3601, lon: -71.0589 },
                    zoom: 8
                },
                height: 600,
                margin: { t: 50, b: 0, l: 0, r: 120 },  // More right margin for legend
                showlegend: true,
                legend: {
                    x: 1.02,
                    y: 0.5,
                    yanchor: 'middle',
                    bgcolor: 'rgba(255,255,255,0.95)',
                    bordercolor: '#ccc',
                    borderwidth: 1,
                    font: {
                        size: 11
                    },
                    title: {
                        text: colorBy === 'OCC_CLS' ? 'Occupancy Class' :
                            colorBy === 'material_type' ? 'Material Type' :
                            'Foundation Type',
                        font: {
                            size: 13,
                            color: '#333',
                            family: 'Arial, sans-serif'
                        }
                    }
                }
            };

            Plotly.newPlot('overviewMapPlot', mapData, layout, {responsive: true});
        }

                function populateHistoricShorelineFilters() {
            // Check if the historic data is loaded and is an array.
            if (!historicShorelineData || !Array.isArray(historicShorelineData)) return;

            const samples = historicShorelineData;
            
            // Get unique values for each category from the dataset.
            const occClasses = ['All', ...new Set(samples.map(s => s.OCC_CLS).filter(Boolean))];
            const materials = ['All', ...new Set(samples.map(s => s.material_type).filter(Boolean))];
            const foundations = ['All', ...new Set(samples.map(s => s.foundation_type).filter(Boolean))];

            /**
             * Helper function to populate a select dropdown.
             * @param {string} selectId - The ID of the select element.
             * @param {Array<string>} options - The array of options to add.
             * @param {Object|null} map - A mapping for display labels (e.g., 'W' -> 'Wood').
             */
            const populate = (selectId, options, map = null) => {
                const select = document.getElementById(selectId);
                // Clear existing options before populating
                select.innerHTML = ''; 
                select.innerHTML = options.map(opt => {
                    const label = map && map[opt] ? `${opt} - ${map[opt]}` : opt;
                    const value = opt === 'All' ? 'All' : opt;
                    return `<option value="${value}">${label}</option>`;
                }).join('');
            };
            
            // Populate the dropdowns with unique IDs for the historic section.
            populate('historicOccFilter', occClasses);
            populate('historicMaterialFilter', materials, materialTypeMap);
            populate('historicFoundationFilter', foundations, foundationTypeMap);
        }


        /**
         * Creates and updates the interactive map for buildings on historic filled land.
         * This function is a direct adaptation of createOverviewMap(), but targets
         * the new data source (historicShorelineData) and new HTML element IDs.
         */
        function createHistoricShorelineMap() {
            // Check if the historic data is available. If not, show a message and exit.
            if (!historicShorelineData) {
                document.getElementById('historicShorelineMapPlot').innerHTML = '<p style="text-align:center; padding-top:100px;">Historic shoreline data is not loaded.</p>';
                return;
            }

            // Get current filter values from the historic section's controls (dropdowns).
            const occFilter = document.getElementById('historicOccFilter').value;
            const materialFilter = document.getElementById('historicMaterialFilter').value;
            const foundationFilter = document.getElementById('historicFoundationFilter').value;
            const colorBy = document.getElementById('historicColorBy').value;

            // Filter the data based on user selections.
            let filteredData = historicShorelineData.filter(d => {
                const occMatch = (occFilter === 'All' || d.OCC_CLS === occFilter);
                const materialMatch = (materialFilter === 'All' || d.material_type === materialFilter);
                const foundationMatch = (foundationFilter === 'All' || d.foundation_type === foundationFilter);
                // Ensure the point has valid coordinates to be plotted.
                return d.LATITUDE && d.LONGITUDE && occMatch && materialMatch && foundationMatch;
            });

            // If there's no data after filtering, display a message.
            if (filteredData.length === 0) {
                document.getElementById('historicShorelineMapPlot').innerHTML = '<p style="text-align:center; padding-top:100px;">No data available for the current filter selection.</p>';
                return;
            }
            
            // Choose the appropriate fixed color mapping based on the 'Color By' dropdown.
            let colorMap;
            if (colorBy === 'OCC_CLS') {
                colorMap = FIXED_OCC_COLORS;
            } else if (colorBy === 'material_type') {
                colorMap = FIXED_MATERIAL_COLORS;
            } else if (colorBy === 'foundation_type') {
                colorMap = FIXED_FOUNDATION_COLORS;
            }
            
            // Get unique categories present in the filtered data to create the legend.
            const colorValues = filteredData.map(d => d[colorBy]);
            const uniqueCategories = [...new Set(colorValues)].filter(cat => cat != null);
            
            // Sort categories for a consistent legend order.
            if (colorBy === 'OCC_CLS') {
                const occOrder = ['Residential', 'Commercial', 'Government', 'Industrial', 
                                'Assembly', 'Unclassified', 'Education', 'Utility and Misc', 'Agriculture'];
                uniqueCategories.sort((a, b) => occOrder.indexOf(a) - occOrder.indexOf(b));
            } else if (colorBy === 'material_type') {
                const materialOrder = ['W', 'M', 'S', 'C', 'H'];
                uniqueCategories.sort((a, b) => materialOrder.indexOf(a) - materialOrder.indexOf(b));
            } else if (colorBy === 'foundation_type') {
                const foundationOrder = ['B', 'S', 'C', 'I', 'P', 'W', 'F'];
                uniqueCategories.sort((a, b) => foundationOrder.indexOf(a) - foundationOrder.indexOf(b));
            } else {
                uniqueCategories.sort();
            }
            
            // Create dummy traces (invisible points) for the legend.
            const legendTraces = uniqueCategories.map(cat => ({
                type: 'scattermapbox',
                lon: [null], lat: [null], mode: 'markers',
                marker: { size: 10, color: colorMap[cat] || '#999999' },
                name: colorBy === 'material_type' ? (materialTypeMap[cat] || cat) :
                    colorBy === 'foundation_type' ? (foundationTypeMap[cat] || cat) :
                    cat,
                showlegend: true, hoverinfo: 'skip'
            }));
            
            // Create the main trace with all the visible building points.
            const mainTrace = {
                type: 'scattermapbox',
                lon: filteredData.map(d => d.LONGITUDE),
                lat: filteredData.map(d => d.LATITUDE),
                mode: 'markers',
                marker: {
                    size: 10,
                    color: colorValues.map(v => colorMap[v] || '#999999'),
                    opacity: 0.8,
                    line: { width: 0.5, color: 'rgba(255,255,255,0.3)' }
                },
                // Define the text that appears on hover.
                text: filteredData.map(d => 
                    `<b>Year Built:</b> ${d.year_built}<br>` +
                    `<b>Occupancy:</b> ${d.OCC_CLS || 'N/A'}<br>` +
                    `<b>Material:</b> ${materialTypeMap[d.material_type] || d.material_type || 'N/A'}<br>` +
                    `<b>Foundation:</b> ${foundationTypeMap[d.foundation_type] || d.foundation_type || 'N/A'}`
                ),
                hovertemplate: '%{text}<extra></extra>',
                showlegend: false
            };
            
            // Combine the main trace and legend traces into one array for plotting.
            const mapData = [mainTrace, ...legendTraces];
            
            // Define the layout for the map (title, map style, center, zoom, etc.).
            const layout = {
                title: {
                    text: `Buildings on Reclaimed Land (${filteredData.length} points shown)`,
                    font: { size: 20, color: '#333' }
                },
                mapbox: {
                    style: 'open-street-map',
                    // Center the map on Boston.
                    center: { lat: 42.355, lon: -71.06 },
                    zoom: 12.5 // Zoom in closer on Boston
                },
                height: 600,
                margin: { t: 50, b: 0, l: 0, r: 120 },
                showlegend: true,
                legend: {
                    x: 1.02, y: 0.5, yanchor: 'middle',
                    bgcolor: 'rgba(255,255,255,0.95)',
                    bordercolor: '#ccc', borderwidth: 1,
                    font: { size: 11 },
                    title: {
                        text: colorBy === 'OCC_CLS' ? 'Occupancy Class' :
                            colorBy === 'material_type' ? 'Material Type' :
                            'Foundation Type',
                        font: { size: 13, color: '#333' }
                    }
                }
            };

            // Render the plot in the designated div using Plotly.
            Plotly.newPlot('historicShorelineMapPlot', mapData, layout, {responsive: true});
        }

                function updateHistoricShorelineCharts() {
            if (!historicShorelineData) return;

            // Get current filter values from the controls.
        
            const occFilter = document.getElementById('historicOccFilter').value;
            const materialFilter = document.getElementById('historicMaterialFilter').value;
            const foundationFilter = document.getElementById('historicFoundationFilter').value;

            // Filter the data based on user selections. This is done only once here.
           
            const filteredData = historicShorelineData.filter(d => {
                const occMatch = (occFilter === 'All' || d.OCC_CLS === occFilter);
                const materialMatch = (materialFilter === 'All' || d.material_type === materialFilter);
                const foundationMatch = (foundationFilter === 'All' || d.foundation_type === foundationFilter);
                return d.LATITUDE && d.LONGITUDE && occMatch && materialMatch && foundationMatch;
            });

            // Call all the chart-drawing functions with the filtered data.
         
            createHistoricShorelineMap(filteredData); // Update the map 
            createHistoricOccupancyChart(filteredData); // Update the new Occupancy chart 
            createHistoricYearChart(filteredData); // Update the new Year chart 
            createHistoricMaterialChart(filteredData); // Update the new Material chart 
            createHistoricFoundationChart(filteredData); // Update the new Foundation chart 
        }

        /**
         * Creates a bar chart for Occupancy Class (OCC_CLS) distribution.

         */
        function createHistoricOccupancyChart(data) {
            const chartDiv = document.getElementById('historicOccupancyChart');
            if (!data || data.length === 0) {
                chartDiv.innerHTML = '<p style="padding: 20px; text-align: center;">No data for Occupancy chart.</p>';
                return;
            }

            const counts = data.reduce((acc, d) => {
                const key = d.OCC_CLS || 'Unknown';
                acc[key] = (acc[key] || 0) + 1;
                return acc;
            }, {});

            const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]);

            // START: MODIFICATION
            // Map occupancy classes to their predefined colors from FIXED_OCC_COLORS.
            const barColors = sorted.map(d => FIXED_OCC_COLORS[d[0]] || '#999999');
            // END: MODIFICATION

            const plotData = [{
                x: sorted.map(d => d[0]),
                y: sorted.map(d => d[1]),
                type: 'bar',
                // Use the mapped colors for the bar chart.
                marker: { color: barColors }
            }];

            const layout = {
                title: { text: 'Distribution by Occupancy' },
                xaxis: { title: 'Occupancy Class', tickangle: -45 },
                yaxis: { title: 'Building Count' },
                height: 400,
                margin: { t: 40, b: 120, l: 60, r: 20 }
            };

            Plotly.newPlot(chartDiv, plotData, layout, { responsive: true });
        }

        /**
         * Creates a bar chart for Year Built distribution.
         * This version now groups years before 1940 into a "pre-1940" category.
         */
        function createHistoricYearChart(data) {
            const chartDiv = document.getElementById('historicYearChart');
            if (!data || data.length === 0) {
                chartDiv.innerHTML = '<p style="padding: 20px; text-align: center;">No data for Year Built chart.</p>';
                return;
            }

            const counts = data.reduce((acc, d) => {
                const year = d.year_built;
                let key;
                
                // START: MODIFICATION
                // First, check if 'year' is a valid number to prevent null/NaN from being miscategorized.
                if (year && !isNaN(year) && year > 0) {
                    // If the year is before 1940, label it as 'pre-1940'.
                    if (year < 1940) {
                        key = 'pre-1940';
                    } else {
                        // Otherwise, group by decade.
                        key = `${Math.floor(year / 10) * 10}s`;
                    }
                } else {
                    // Group all other cases (null, NaN, 0) as 'Unknown'.
                    key = 'Unknown';
                }
                // END: MODIFICATION

                acc[key] = (acc[key] || 0) + 1;
                return acc;
            }, {});

            // Custom sort to ensure 'pre-1940' and 'Unknown' are handled correctly.
            const sorted = Object.entries(counts).sort((a, b) => {
                if (a[0] === 'pre-1940') return -1;
                if (b[0] === 'pre-1940') return 1;
                if (a[0] === 'Unknown') return 1;
                if (b[0] === 'Unknown') return -1;
                return a[0].localeCompare(b[0]);
            });

            const plotData = [{
                x: sorted.map(d => d[0]),
                y: sorted.map(d => d[1]),
                type: 'bar',
                marker: { color: getPlasmaColors(sorted.length).reverse() }
            }];

            const layout = {
                title: { text: 'Distribution by Year Built' },
                xaxis: { title: 'Decade', tickangle: -45 },
                yaxis: { title: 'Building Count' },
                height: 400,
                margin: { t: 40, b: 120, l: 60, r: 20 }
            };

            Plotly.newPlot(chartDiv, plotData, layout, { responsive: true });
        }
        /**
         * Creates a bar chart for Material Type distribution.
    
         */
        function createHistoricMaterialChart(data) {
            const chartDiv = document.getElementById('historicMaterialChart');
            if (!data || data.length === 0) {
                chartDiv.innerHTML = '<p style="padding: 20px; text-align: center;">No data for Material chart.</p>';
                return;
            }

            const counts = data.reduce((acc, d) => {
                // Use the mapping to get full names (e.g., 'W' -> 'Wood').
               
                const key = materialTypeMap[d.material_type] || d.material_type || 'Unknown';
                acc[key] = (acc[key] || 0) + 1;
                return acc;
            }, {});

            const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]);

            const plotData = [{
                x: sorted.map(d => d[0]),
                y: sorted.map(d => d[1]),
                type: 'bar',
                marker: { color: plasmaColors }
            }];

            const layout = {
                title: { text: 'Distribution by Material' },
                xaxis: { title: 'Material Type' },
                yaxis: { title: 'Building Count' },
                height: 400,
                margin: { t: 40, b: 80, l: 60, r: 20 }
            };

            Plotly.newPlot(chartDiv, plotData, layout, { responsive: true });
        }

        /**
         * Creates a bar chart for Foundation Type distribution.
   
         */
        function createHistoricFoundationChart(data) {
            const chartDiv = document.getElementById('historicFoundationChart');
            if (!data || data.length === 0) {
                chartDiv.innerHTML = '<p style="padding: 20px; text-align: center;">No data for Foundation chart.</p>';
                return;
            }

            const counts = data.reduce((acc, d) => {
                // Use the mapping to get full names (e.g., 'B' -> 'Basement').
       
                const key = foundationTypeMap[d.foundation_type] || d.foundation_type || 'Unknown';
                acc[key] = (acc[key] || 0) + 1;
                return acc;
            }, {});

            const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]);

            const plotData = [{
                x: sorted.map(d => d[0]),
                y: sorted.map(d => d[1]),
                type: 'bar',
                marker: { color: plasmaColors }
            }];

            const layout = {
                title: { text: 'Distribution by Foundation' },
                xaxis: { title: 'Foundation Type' },
                yaxis: { title: 'Building Count' },
                height: 400,
                margin: { t: 40, b: 80, l: 60, r: 20 }
            };

            Plotly.newPlot(chartDiv, plotData, layout, { responsive: true });
        }

        // 用下面的函数完整替换掉旧的 createDataSourcesFlowchart 函数
        function createDataSourcesFlowchart() {
            // Create Sankey diagram to show data flow
            const sourceNames = Object.keys(dataSourceColumns);
            const finalDatasetName = 'NSI-Enhanced USA Structures Dataset';
            const labels = [...sourceNames, finalDatasetName];
            
            const sources = sourceNames.map((_, i) => i);
            const targets = sourceNames.map(() => sourceNames.length);
            const values = sourceNames.map(name => dataSourceColumns[name].columns.length);
            const totalColumns = values.reduce((a, b) => a + b, 0);
            
            const nodeColors = sourceNames.map(name => dataSourceColumns[name].color);
            nodeColors.push('#2c3e50'); // Final dataset color
            
            const sankeyData = [{
                type: 'sankey',
                orientation: 'h',
                node: {
                    pad: 15,
                    thickness: 30,
                    line: {
                        color: 'white',
                        width: 2
                    },
                    label: labels.map((label, i) => {
                        if (i < sourceNames.length) {
                            const source = dataSourceColumns[label];
                            return `${source.icon} ${label}<br><span style="font-size: 11px;">(${source.columns.length} columns)</span>`;
                        }
                        return `🎯 ${label}<br><span style="font-size: 11px;">(${totalColumns} total columns)</span>`;
                    }),
                    color: nodeColors,
                    customdata: labels.map(label => dataSourceColumns[label]),
                    hovertemplate: '%{label}<br><b>Click to see columns</b><extra></extra>'
                },
                link: {
                    source: sources,
                    target: targets,
                    value: values,
                    color: sources.map(i => nodeColors[i] + '40'), // Add transparency
                    hovertemplate: '%{source.label} → %{target.label}<br>%{value} columns<extra></extra>'
                }
            }];
            
            const sankeyLayout = {
                font: { size: 14, family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif' },
                height: 400,
                margin: { t: 20, b: 20, l: 150, r: 150 },
                plot_bgcolor: 'transparent',
                paper_bgcolor: 'transparent'
            };
            
            Plotly.newPlot('dataSourcesFlowchart', sankeyData, sankeyLayout, {
                responsive: true,
                displayModeBar: false
            });
            
            document.getElementById('dataSourcesFlowchart').on('plotly_click', function(eventData) {
                if (eventData.points && eventData.points[0] && eventData.points[0].pointNumber !== undefined) {
                    const pointIndex = eventData.points[0].pointNumber;
                    if (pointIndex < sourceNames.length) { 
                        const sourceName = labels[pointIndex];
                        showColumnDetails(sourceName);
                    } else {
                        showAllColumns();
                    }
                }
            });
            
            setTimeout(() => {
                addFloatingBadges();
            }, 500);
        }


        function showAllColumns() {
            const panel = document.getElementById('columnDetailsPanel');
            const title = document.getElementById('columnDetailsTitle');
            const list = document.getElementById('columnDetailsList');
            
            title.innerHTML = `<span style="color: #2c3e50;">🎯 Complete NSI-Enhanced Dataset</span> - All integrated columns`;
            
            list.innerHTML = '';
            Object.entries(dataSourceColumns).forEach(([sourceName, source]) => {
                const sourceDiv = document.createElement('div');
                sourceDiv.style.gridColumn = 'span 3';
                sourceDiv.innerHTML = `
                    <h4 style="color: ${source.color}; margin: 15px 0 10px 0;">
                        ${source.icon} From ${sourceName} (${source.columns.length} columns)
                    </h4>
                    <div style="display: flex; flex-wrap: wrap; gap: 5px;">
                        ${source.columns.map(col => `
                            <span style="
                                background: ${source.color}20;
                                color: ${source.color};
                                padding: 4px 10px;
                                border-radius: 15px;
                                font-size: 11px;
                                border: 1px solid ${source.color}40;
                            ">${col}</span>
                        `).join('')}
                    </div>
                `;
                list.appendChild(sourceDiv);
            });
            
            panel.style.display = 'block';
        }

        function showColumnDetails(sourceName) {
            const source = dataSourceColumns[sourceName];
            if (!source) return;
            
            const panel = document.getElementById('columnDetailsPanel');
            const title = document.getElementById('columnDetailsTitle');
            const list = document.getElementById('columnDetailsList');
            
            title.innerHTML = `<span style="color: ${source.color};">${source.icon} ${sourceName}</span> - ${source.description}`;
            
            // Group columns by category for better organization
            const columnCategories = categorizeColumns(source.columns);
            
            list.innerHTML = '';
            Object.entries(columnCategories).forEach(([category, cols]) => {
                const categoryDiv = document.createElement('div');
                categoryDiv.style.gridColumn = 'span ' + Math.min(cols.length > 5 ? 2 : 1, 3);
                categoryDiv.innerHTML = `
                    <h5 style="color: ${source.color}; margin-bottom: 10px; font-size: 14px; text-transform: uppercase; letter-spacing: 1px;">
                        ${category}
                    </h5>
                    <div style="display: flex; flex-wrap: wrap; gap: 5px;">
                        ${cols.map(col => `
                            <span style="
                                background: ${source.color}20;
                                color: ${source.color};
                                padding: 4px 10px;
                                border-radius: 15px;
                                font-size: 12px;
                                border: 1px solid ${source.color}40;
                                display: inline-block;
                            ">${col}</span>
                        `).join('')}
                    </div>
                `;
                list.appendChild(categoryDiv);
            });
            
            panel.style.display = 'block';
            panel.style.opacity = '0';
            setTimeout(() => {
                panel.style.transition = 'opacity 0.3s ease';
                panel.style.opacity = '1';
            }, 10);
        }

        function categorizeColumns(columns) {
            const categories = {
                'Identifiers': [],
                'Location': [],
                'Properties': [],
                'Measurements': [],
                'Environmental': [],
                'Metadata': []
            };
            
            columns.forEach(col => {
                const colLower = col.toLowerCase();
                if (colLower.includes('id') || colLower.includes('uuid') || colLower.includes('key')) {
                    categories['Identifiers'].push(col);
                } else if (colLower.includes('lat') || colLower.includes('long') || colLower.includes('addr') || 
                        colLower.includes('city') || colLower.includes('zip') || colLower.includes('fips') ||
                        colLower.includes('geometry') || colLower.includes('usng')) {
                    categories['Location'].push(col);
                } else if (colLower.includes('sqm') || colLower.includes('sqf') || colLower.includes('height') ||
                        colLower.includes('elev') || colLower.includes('area') || colLower.includes('length')) {
                    categories['Measurements'].push(col);
                } else if (colLower.includes('soil') || colLower.includes('drain') || colLower.includes('flood') ||
                        colLower.includes('eng_') || colLower.includes('gwp') || colLower.includes('wt')) {
                    categories['Environmental'].push(col);
                } else if (colLower.includes('date') || colLower.includes('source') || colLower.includes('method') ||
                        colLower.includes('image') || colLower.includes('remark')) {
                    categories['Metadata'].push(col);
                } else {
                    categories['Properties'].push(col);
                }
            });
            
            // Remove empty categories
            return Object.fromEntries(
                Object.entries(categories).filter(([_, cols]) => cols.length > 0)
            );
        }


        function addFloatingBadges() {
            const container = document.getElementById('dataSourcesFlowchart');
            if (!container) return;
            
            // Add summary stats as floating badges
            const stats = [
                { label: 'Total Columns', value: '65', color: '#2c3e50' },
                { label: 'Data Sources', value: '4', color: '#667eea' },
                { label: 'MA Buildings', value: '2.09M+', color: '#764ba2' }
            ];
            
            const badgeContainer = document.createElement('div');
            badgeContainer.style.cssText = `
                position: absolute;
                top: 20px;
                right: 20px;
                display: flex;
                gap: 15px;
                z-index: 10;
            `;
            
            stats.forEach(stat => {
                const badge = document.createElement('div');
                badge.style.cssText = `
                    background: white;
                    border: 2px solid ${stat.color};
                    border-radius: 20px;
                    padding: 8px 16px;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                    animation: fadeInBadge 0.5s ease;
                `;
                badge.innerHTML = `
                    <div style="font-size: 18px; font-weight: bold; color: ${stat.color};">${stat.value}</div>
                    <div style="font-size: 11px; color: #666;">${stat.label}</div>
                `;
                badgeContainer.appendChild(badge);
            });
            
            // Only add if not already present
            if (!container.querySelector('.badge-container')) {
                badgeContainer.className = 'badge-container';
                container.style.position = 'relative';
                container.appendChild(badgeContainer);
            }
        }



        function updateClusteringWithNewK() {
            const newK = parseInt(document.getElementById('clusterCount').value);
            currentClusterK = newK;
            document.getElementById('numClusters').textContent = currentClusterK.toString();
            updateClustering();
        }

    function updateClustering() {
        if (!buildingData) return;

        // The data for the statistics table and treemap now comes from the more detailed
        // 'occupancy_clusters' object, which holds pre-calculated results for multiple K values.
        const allClustersData = buildingData.occupancy_clusters?.all?.k_values;
        const samples = buildingData.building_samples_random;

        if (!allClustersData || !samples) {
            console.error("Required clustering data is not available.");
            document.getElementById('clusterScatter').innerHTML = "<p>Clustering data is missing.</p>";
            return;
        }

        // --- FIX #1: USE REAL, PRE-CALCULATED CLUSTER ASSIGNMENTS ---
        // Instead of random assignments, we now map each sample point to its true
        // pre-calculated cluster for the currently selected K value.
        // The Python script saves these as columns like 'cluster_base_k5', 'cluster_base_k7', etc.
        const samplesWithRealClusters = samples.map(s => ({
            ...s,
            // Dynamically select the correct cluster column based on the chosen K.
            displayCluster: s[`cluster_base_k${currentClusterK}`]
        }));

        // --- Scatter Plot (Now shows REAL clusters) ---
        const scatterData = [];
        for (let i = 0; i < currentClusterK; i++) {
            const clusterSamples = samplesWithRealClusters.filter(s => s.displayCluster === i);
            if (clusterSamples.length > 0) {
                scatterData.push({
                    x: clusterSamples.map(s => s.year_built < 1940 ? 'pre-1940' : s.year_built),
                    y: clusterSamples.map(s => s.SQMETERS),
                    mode: 'markers',
                    type: 'scatter',
                    name: `Cluster ${i + 1}`,
                    marker: { color: plasmaColors[i % plasmaColors.length], size: 8, opacity: 0.6 },
                    hovertemplate: 'Year: %{x}<br>Est GFA: %{y:.1f} sqm<br><b>Cluster: ' + (i + 1) + '</b><extra></extra>'
                });
            }
        }
        const scatterLayout = {
            title: { text: `K-Means Clustering Results (K=${currentClusterK})`, font: { size: 20, color: '#333' } },
            xaxis: { title: 'Year Built' },
            yaxis: { title: 'Footprint Area (sqm)' },
            height: 500,
            hovermode: 'closest'
        };
        Plotly.newPlot('clusterScatter', scatterData, scatterLayout, { responsive: true });

        // --- Elbow Plot (Now uses REAL WCSS data for all K values) ---
        const elbowKValues = Object.keys(allClustersData).map(Number);
        const elbowWcssValues = elbowKValues.map(k => allClustersData[k].wcss);
        
        const elbowData = [{
            x: elbowKValues,
            y: elbowWcssValues,
            mode: 'lines+markers',
            type: 'scatter',
            marker: { size: 10, color: plasmaColors[3], line: { color: 'white', width: 2 } },
            line: { width: 3, color: plasmaColors[3] },
            hovertemplate: 'K: %{x}<br>WCSS: %{y:,.0f}<extra></extra>'
        }];
        const elbowLayout = {
            title: { text: 'Elbow Method for Optimal K', font: { size: 20, color: '#333' } },
            xaxis: { title: 'Number of Clusters (K)', dtick: 1 },
            yaxis: { title: 'Within-Cluster Sum of Squares (WCSS)' },
            height: 400
        };
        Plotly.newPlot('clusterElbow', elbowData, elbowLayout, { responsive: true });

        // --- Statistics Table and Treemap (Now use REAL data for the selected K) ---
        const clusterStatsForK = allClustersData[currentClusterK];
        if (clusterStatsForK && clusterStatsForK.clusters) {
            const displayClusters = clusterStatsForK.clusters;

            // Statistics Table
            const tableData = [{
                type: 'table',
                header: { values: ['Cluster', 'Count', 'Avg Footprint (m²)', 'Avg Height (m)', 'Avg Year'], align: 'center', line: {width: 1, color: '#dee2e6'}, fill: {color: plasmaColors[3]}, font: {family: "Arial", size: 14, color: "white"} },
                cells: {
                    values: [
                        displayClusters.map(c => `Cluster ${c.cluster_id + 1}`),
                        displayClusters.map(c => c.count.toLocaleString()),
                        displayClusters.map(c => Math.round(c.avg_sqmeters)),
                        displayClusters.map(c => c.avg_height.toFixed(1)),
                        displayClusters.map(c => c.avg_year)
                    ],
                    align: 'center', line: {color: "#dee2e6", width: 1}, fill: {color: ['#f8f9fa', 'white']}, font: {family: "Arial", size: 12, color: ["#333"]}
                }
            }];
            const tableLayout = { title: { text: `Cluster Statistics (K=${currentClusterK}, Based on Full Dataset)`, font: { size: 18, color: '#333' } }, height: 400 };
            Plotly.newPlot('clusterTable', tableData, tableLayout, { responsive: true });

            // Treemap
            updateClusterTreemap(); // Pass the correct data to the treemap function
        } else {
            // Handle cases where data for a specific K might be missing
            document.getElementById('clusterTable').innerHTML = `<p>No statistics available for K=${currentClusterK}.</p>`;
            document.getElementById('clusterTreemap').innerHTML = '';
        }
    }

    // You also need to slightly modify `updateClusterTreemap` to accept data as an argument.
    // Find `updateClusterTreemap()` and replace it with this new version.
    function updateClusterTreemap() {
            if (!buildingData) return;


            const allClustersData = buildingData.occupancy_clusters?.all?.k_values;
            if (!allClustersData) return;
            
            const clusterStatsForK = allClustersData[currentClusterK]; // 'currentClusterK' 
            if (!clusterStatsForK || !clusterStatsForK.clusters) return;
            
            const clusters = clusterStatsForK.clusters; 
            
            const sizeBy = document.getElementById('treemapSizeBy').value;
        
        const labels = ['All Clusters'];
        const parents = [''];
        const values = [0];
        const colors = [''];
        
        clusters.forEach((cluster, index) => {
            // The new data doesn't have 'most_common_occ', so we create a simple label.
            const label = `Cluster ${index + 1}`;
            labels.push(label);
            parents.push('All Clusters');
            
            // The new data uses 'avg_sqmeters', not 'area_mean'.
            if (sizeBy === 'count') {
                values.push(cluster.count);
            } else {

                values.push(cluster.count * (cluster.avg_gfa || cluster.avg_sqmeters));
            }
            colors.push(plasmaColors[index % plasmaColors.length]);
        });
        
        const treemapData = [{
            type: 'treemap',
            labels: labels,
            parents: parents,
            values: values,
            marker: { colors: colors },
            textinfo: 'label+value+percent parent',
            hovertemplate: '%{label}<br>Value: %{value:,}<br>%{percentParent}<extra></extra>'
        }];
        
        const treemapLayout = {
            title: { text: `Cluster Treemap (Sized by ${sizeBy === 'count' ? 'Building Count' : 'Total Floor Area'})`, font: { size: 18, color: '#333' } },
            height: 500
        };
        
        Plotly.newPlot('clusterTreemap', treemapData, treemapLayout, {responsive: true});
    }


        function updateTemporalChart() {
            if (!buildingData) return;
            
            const chartType = document.getElementById('chartType').value;
            const buildingType = document.getElementById('buildingType').value;
            
            const yearlyData = {};
            const yearlyAreaData = {};
            
            buildingData.temporal_data.forEach(d => {
                const key = d.year < 1940 ? 'pre-1940' : d.year.toString();
                
                if (!yearlyData[key]) {
                    yearlyData[key] = {};
                    yearlyAreaData[key] = {};
                }
                if (!yearlyData[key][d.occupancy]) {
                    yearlyData[key][d.occupancy] = 0;
                    yearlyAreaData[key][d.occupancy] = 0;
                }
                yearlyData[key][d.occupancy] += d.count;
                yearlyAreaData[key][d.occupancy] += d.total_area || (d.count * d.avg_area);
            });
            
            let occupancyClasses = buildingData.summary_stats.occupancy_classes;
            if (buildingType === 'residential') {
                occupancyClasses = ['Residential'];
            } else if (buildingType === 'non-residential') {
                occupancyClasses = occupancyClasses.filter(o => o !== 'Residential');
            }
            
            occupancyClasses = occupancyClasses.sort((a, b) => {
                if (a === 'Residential') return -1;
                if (b === 'Residential') return 1;
                return a.localeCompare(b);
            });
            
            const xValues = Object.keys(yearlyData).sort((a, b) => {
                if (a === 'pre-1940') return -1;
                if (b === 'pre-1940') return 1;
                return parseInt(a) - parseInt(b);
            });
            
            const tickvals = xValues.filter((y, i) => {
                if (y === 'pre-1940') return false;
                const year = parseInt(y);
                return year % 10 === 0;
            });
            
            const traces = [];
            const occupancyColors = getPlasmaColors(occupancyClasses.length);
            
            if (chartType === 'line') {
                occupancyClasses.forEach((occ, index) => {
                    const yValues = xValues.map(year => yearlyData[year][occ] || 0);
                    traces.push({
                        x: xValues,
                        y: yValues,
                        name: occ,
                        type: 'scatter',
                        mode: 'lines+markers',
                        line: { color: occupancyColors[index], width: 2 },
                        marker: { color: occupancyColors[index], size: 4 },
                        hovertemplate: `%{fullData.name}<br>%{x}: %{y:,}<extra></extra>`
                    });
                });
            } else if (chartType === 'stacked') {
                occupancyClasses.forEach((occ, index) => {
                    const yValues = xValues.map(year => yearlyData[year][occ] || 0);
                    traces.push({
                        x: xValues,
                        y: yValues,
                        name: occ,
                        type: 'scatter',
                        mode: 'lines',
                        stackgroup: 'one',
                        fillcolor: occupancyColors[index],
                        line: { color: occupancyColors[index], width: 0.5 },
                        hovertemplate: `%{fullData.name}<br>%{x}: %{y:,}<extra></extra>`
                    });
                });
            } else if (chartType === 'normalized') {
                occupancyClasses.forEach((occ, index) => {
                    const yValues = xValues.map(year => {
                        const total = occupancyClasses.reduce((sum, o) => 
                            sum + (yearlyData[year][o] || 0), 0);
                        return total > 0 ? ((yearlyData[year][occ] || 0) / total) * 100 : 0;
                    });
                    traces.push({
                        x: xValues,
                        y: yValues,
                        name: occ,
                        type: 'scatter',
                        mode: 'lines',
                        stackgroup: 'one',
                        groupnorm: 'percent',
                        fillcolor: occupancyColors[index],
                        line: { color: occupancyColors[index], width: 0.5 },
                        hovertemplate: `%{fullData.name}<br>%{x}: %{y:.1f}%<extra></extra>`
                    });
                });
            } else if (chartType === 'cumulative') {
                occupancyClasses.forEach((occ, index) => {
                    const yValues = xValues.map(year => yearlyData[year][occ] || 0);
                    const cumulativeY = yValues.reduce((acc, val) => {
                        acc.push((acc.length > 0 ? acc[acc.length - 1] : 0) + val);
                        return acc;
                    }, []);
                    traces.push({
                        x: xValues,
                        y: cumulativeY,
                        name: occ,
                        type: 'scatter',
                        mode: 'lines',
                        fill: 'tozeroy',
                        fillcolor: occupancyColors[index] + '40',
                        line: { color: occupancyColors[index], width: 2 },
                        hovertemplate: `%{fullData.name}<br>%{x}: %{y:,}<extra></extra>`
                    });
                });
            }
            
            const layout = {
                title: {
                    text: chartType === 'cumulative' ? 'Cumulative Buildings Over Time' : 'Buildings Constructed Over Time',
                    font: { size: 20, color: '#333' }
                },
                xaxis: { 
                    title: 'Year',
                    type: 'category',
                    tickmode: 'array',
                    tickvals: tickvals,
                    ticktext: tickvals,
                    tickangle: -45
                },
                yaxis: { 
                    title: chartType === 'normalized' ? 'Percentage (%)' : 
                           chartType === 'cumulative' ? 'Cumulative Number of Buildings' : 
                           'Number of Buildings Constructed Per Year',
                    range: chartType === 'normalized' ? [0, 100] : undefined
                },
                height: 500,
                hovermode: 'x unified',
                showlegend: true,
                legend: {
                    orientation: 'v',
                    yanchor: 'middle',
                    y: 0.5,
                    xanchor: 'left',
                    x: 1.02
                }
            };
            
            Plotly.newPlot('temporalChart', traces, layout, {responsive: true});
            
            // Area chart
            const areaTraces = [];
            
            if (chartType === 'line') {
                occupancyClasses.forEach((occ, index) => {
                    const yValues = xValues.map(year => yearlyAreaData[year][occ] || 0);
                    areaTraces.push({
                        x: xValues,
                        y: yValues,
                        name: occ,
                        type: 'scatter',
                        mode: 'lines+markers',
                        line: { color: occupancyColors[index], width: 2 },
                        marker: { color: occupancyColors[index], size: 4 },
                        hovertemplate: `%{fullData.name}<br>%{x}: %{y:,.0f} sqm<extra></extra>`
                    });
                });
            } else if (chartType === 'stacked') {
                occupancyClasses.forEach((occ, index) => {
                    const yValues = xValues.map(year => yearlyAreaData[year][occ] || 0);
                    areaTraces.push({
                        x: xValues,
                        y: yValues,
                        name: occ,
                        type: 'scatter',
                        mode: 'lines',
                        stackgroup: 'one',
                        fillcolor: occupancyColors[index],
                        line: { color: occupancyColors[index], width: 0.5 },
                        hovertemplate: `%{fullData.name}<br>%{x}: %{y:,.0f} sqm<extra></extra>`
                    });
                });
            } else if (chartType === 'normalized') {
                occupancyClasses.forEach((occ, index) => {
                    const yValues = xValues.map(year => {
                        const total = occupancyClasses.reduce((sum, o) => 
                            sum + (yearlyAreaData[year][o] || 0), 0);
                        return total > 0 ? ((yearlyAreaData[year][occ] || 0) / total) * 100 : 0;
                    });
                    areaTraces.push({
                        x: xValues,
                        y: yValues,
                        name: occ,
                        type: 'scatter',
                        mode: 'lines',
                        stackgroup: 'one',
                        groupnorm: 'percent',
                        fillcolor: occupancyColors[index],
                        line: { color: occupancyColors[index], width: 0.5 },
                        hovertemplate: `%{fullData.name}<br>%{x}: %{y:.1f}%<extra></extra>`
                    });
                });
            } else if (chartType === 'cumulative') {
                occupancyClasses.forEach((occ, index) => {
                    const yValues = xValues.map(year => yearlyAreaData[year][occ] || 0);
                    const cumulativeY = yValues.reduce((acc, val) => {
                        acc.push((acc.length > 0 ? acc[acc.length - 1] : 0) + val);
                        return acc;
                    }, []);
                    areaTraces.push({
                        x: xValues,
                        y: cumulativeY,
                        name: occ,
                        type: 'scatter',
                        mode: 'lines',
                        fill: 'tozeroy',
                        fillcolor: occupancyColors[index] + '40',
                        line: { color: occupancyColors[index], width: 2 },
                        hovertemplate: `%{fullData.name}<br>%{x}: %{y:,.0f} sqm<extra></extra>`
                    });
                });
            }
            
            const areaLayout = {
                title: {
                    text: chartType === 'cumulative' ? 'Cumulative Total Est GFA sqmeters' : 'Total Est GFA sqmeters Constructed Per Year',
                    font: { size: 20, color: '#333' }
                },
                xaxis: { 
                    title: 'Year',
                    type: 'category',
                    tickmode: 'array',
                    tickvals: tickvals,
                    ticktext: tickvals,
                    tickangle: -45
                },
                yaxis: { 
                    title: chartType === 'normalized' ? 'Percentage (%)' : 
                           chartType === 'cumulative' ? 'Cumulative Est GFA sqmeters' :
                           'Total Est GFA sqmeters Constructed Per Year',
                    range: chartType === 'normalized' ? [0, 100] : undefined
                },
                height: 500,
                hovermode: 'x unified',
                showlegend: true,
                legend: {
                    orientation: 'v',
                    yanchor: 'middle',
                    y: 0.5,
                    xanchor: 'left',
                    x: 1.02
                }
            };
            
            Plotly.newPlot('temporalAreaChart', areaTraces, areaLayout, {responsive: true});
            
            // Trend chart
            const trendData = [];
            const years = Object.keys(yearlyData).sort((a, b) => {
                if (a === 'pre-1940') return -1;
                if (b === 'pre-1940') return 1;
                return parseInt(a) - parseInt(b);
            });
            
            const residentialPercentages = years.map(year => {
                const residential = yearlyData[year]['Residential'] || 0;
                const total = Object.values(yearlyData[year]).reduce((sum, val) => sum + val, 0);
                return total > 0 ? (residential / total) * 100 : 0;
            });
            
            trendData.push({
                x: years,
                y: residentialPercentages,
                type: 'scatter',
                mode: 'lines+markers',
                name: 'Residential %',
                line: { 
                    color: '#bd3786',
                    width: 3
                },
                marker: {
                    size: 6,
                    color: '#bd3786'
                },
                hovertemplate: 'Year: %{x}<br>Residential: %{y:.1f}%<extra></extra>'
            });
            
            const trendTickvals = years.filter((y, i) => {
                if (y === 'pre-1940') return false;
                const year = parseInt(y);
                return year % 10 === 0;
            });
            
            const trendLayout = {
                title: {
                    text: 'Residential Building Percentage Trend',
                    font: { size: 20, color: '#333' }
                },
                xaxis: { 
                    title: 'Year',
                    type: 'category',
                    tickmode: 'array',
                    tickvals: trendTickvals,
                    ticktext: trendTickvals,
                    tickangle: -45
                },
                yaxis: { 
                    title: 'Percentage (%)', 
                    range: [0, 100]
                },
                height: 400,
                hovermode: 'x'
            };
            
            Plotly.newPlot('temporalTrendChart', trendData, trendLayout, {responsive: true});
        }


        function updatePre1940Charts() {
            if (!buildingData) return;
            
            const filter = document.getElementById('pre1940Filter').value;
            const normalize = document.getElementById('pre1940Normalize').checked;
            const pre1940 = buildingData.pre1940;
            let occupancyCounts = {...pre1940.occupancy_counts};
            
            if (filter === 'residential') {
                occupancyCounts = { 'Residential': occupancyCounts['Residential'] };
            } else if (filter === 'non-residential') {
                delete occupancyCounts['Residential'];
            }
            
            const pieValues = Object.values(occupancyCounts);
            const pieLabels = Object.keys(occupancyCounts);
            const total = pieValues.reduce((a, b) => a + b, 0);

            const textArray = pieLabels.map((label, i) => {
                const percentage = (pieValues[i] / total * 100);
                
                if (percentage > 10) {
                    return `${label}<br>${percentage.toFixed(1)}%`;
                } else if (percentage > 5) {
                    return `${percentage.toFixed(1)}%`;
                } else if (percentage > 2) {
                    return `${percentage.toFixed(0)}%`;
                } else {
                    return '';
                }
            });

            const pieData = [{
                values: pieValues,
                labels: pieLabels,
                type: 'pie',
                hole: 0.4,
                marker: {
                    colors: plasmaColors
                },
                text: textArray,
                textinfo: 'text',
                textposition: 'auto',
                textfont: {
                    size: 12,
                    color: 'white'
                },
                insidetextorientation: 'radial',
                hovertemplate: '%{label}<br>Count: %{value:,}<br>%{percent}<extra></extra>',
                showlegend: true
            }];
            
            const pieLayout = {
                title: {
                    text: `Pre-1940 Building Distribution (${filter})`,
                    font: { size: 20, color: '#333' }
                },
                height: 450,
                legend: {
                    orientation: 'v',
                    yanchor: 'middle',
                    y: 0.5,
                    xanchor: 'left',
                    x: 1.02
                }
            };
            
            Plotly.newPlot('pre1940PieChart', pieData, pieLayout, {responsive: true});
            
            const sortedOccupancies = Object.entries(occupancyCounts)
                .sort((a, b) => b[1] - a[1]);
            
            const barData = [{
                x: sortedOccupancies.map(([k, v]) => k),
                y: sortedOccupancies.map(([k, v]) => v),
                type: 'bar',
                marker: {
                    color: plasmaColors,
                    line: {
                        color: 'white',
                        width: 1
                    }
                },
                hovertemplate: '%{x}<br>Count: %{y:,}<extra></extra>'
            }];
            
            const barLayout = {
                title: {
                    text: `Pre-1940 Building Counts by Occupancy (${filter})`,
                    font: { size: 20, color: '#333' }
                },
                xaxis: { 
                    title: 'Occupancy Class',
                    tickangle: -45
                },
                yaxis: { 
                    title: 'Number of Buildings',
                    type: 'log'
                },
                height: 450
            };
            
            Plotly.newPlot('pre1940BarChart', barData, barLayout, {responsive: true});
            
            const comparisonData = [
                {
                    x: ['Residential', 'Non-Residential'],
                    y: [pre1940.residential_count, pre1940.non_residential_count],
                    type: 'bar',
                    name: 'Pre-1940',
                    marker: { color: [plasmaColors[3], plasmaColors[6]] }
                }
            ];
            
            const comparisonLayout = {
                title: {
                    text: 'Residential vs Non-Residential (Pre-1940)',
                    font: { size: 20, color: '#333' }
                },
                xaxis: { title: 'Building Type' },
                yaxis: { title: 'Number of Buildings' },
                height: 400
            };
            
            Plotly.newPlot('pre1940ComparisonChart', comparisonData, comparisonLayout, {responsive: true});
            
            const pre1940AreaData = {};
            
            buildingData.temporal_data.forEach(d => {
                if (d.year < 1940) {
                    if (!pre1940AreaData[d.occupancy]) {
                        pre1940AreaData[d.occupancy] = 0;
                    }
                    pre1940AreaData[d.occupancy] += d.total_area || (d.count * d.avg_area);
                }
            });
            
            let filteredAreaData = {...pre1940AreaData};
            if (filter === 'residential') {
                filteredAreaData = { 'Residential': filteredAreaData['Residential'] || 0 };
            } else if (filter === 'non-residential') {
                delete filteredAreaData['Residential'];
            }
            
            const sortedAreaData = Object.entries(filteredAreaData)
                .sort((a, b) => b[1] - a[1]);
            
            let areaValues = sortedAreaData.map(([k, v]) => v);
            
            if (normalize) {
                const total = areaValues.reduce((sum, val) => sum + val, 0);
                areaValues = areaValues.map(val => total > 0 ? (val / total) * 100 : 0);
            }
            
            const areaChartData = [{
                x: sortedAreaData.map(([k, v]) => k),
                y: areaValues,
                type: 'bar',
                marker: {
                    color: getPlasmaColors(sortedAreaData.length),
                    line: {
                        color: 'white',
                        width: 1
                    }
                },
                hovertemplate: `%{x}<br>Area: %{y:.0f}${normalize ? '%' : ' sqm'}<extra></extra>`
            }];
            
            const areaChartLayout = {
                title: {
                    text: `Pre-1940 Total Est GFA sqmeters by Occupancy (${filter})${normalize ? ' - Normalized' : ''}`,
                    font: { size: 20, color: '#333' }
                },
                xaxis: { 
                    title: 'Occupancy Class',
                    tickangle: -45
                },
                yaxis: { 
                    title: normalize ? 'Percentage (%)' : 'Total Est GFA sqmeters',
                    range: normalize ? [0, 100] : undefined
                },
                height: 450
            };
            
            Plotly.newPlot('pre1940AreaChart', areaChartData, areaChartLayout, {responsive: true});
        }


        function updatePost1940() {
            if (!buildingData) return;
            
            const buildingTypeFilter = document.getElementById('post1940BuildingType').value;
            const normalize = document.getElementById('post1940Normalize').checked;
            
            const annualData = {};
            const annualAreaData = {};
            
            buildingData.temporal_data.forEach(d => {
                if (d.year >= 1940) {
                    if (!annualData[d.year]) {
                        annualData[d.year] = {};
                        annualAreaData[d.year] = {};
                    }
                    if (!annualData[d.year][d.occupancy]) {
                        annualData[d.year][d.occupancy] = 0;
                        annualAreaData[d.year][d.occupancy] = 0;
                    }
                    annualData[d.year][d.occupancy] += d.count;
                    annualAreaData[d.year][d.occupancy] += d.total_area || (d.count * d.avg_area);
                }
            });
            
            let occupancyTypes = new Set();
            Object.values(annualData).forEach(yearData => {
                Object.keys(yearData).forEach(occ => occupancyTypes.add(occ));
            });
            
            if (buildingTypeFilter === 'residential') {
                occupancyTypes = new Set(['Residential']);
            } else if (buildingTypeFilter === 'non-residential') {
                occupancyTypes.delete('Residential');
            }
            
            const traces = [];
            const years = Object.keys(annualData).sort((a, b) => a - b);
            const occupancyColors = getPlasmaColors(occupancyTypes.size);
            
            if (normalize) {
                Array.from(occupancyTypes).forEach((occ, index) => {
                    const yValues = years.map(year => annualData[year][occ] || 0);
                    
                    traces.push({
                        x: years,
                        y: yValues,
                        name: occ,
                        type: 'scatter',
                        mode: 'lines',
                        stackgroup: 'one',
                        groupnorm: 'percent',
                        fillcolor: occupancyColors[index],
                        line: { color: occupancyColors[index], width: 0.5 },
                        hovertemplate: `%{fullData.name}<br>Year: %{x}<br>Percentage: %{y:.1f}%<extra></extra>`
                    });
                });
            } else {
                Array.from(occupancyTypes).forEach((occ, index) => {
                    const yValues = years.map(year => annualData[year][occ] || 0);
                    
                    traces.push({
                        x: years,
                        y: yValues,
                        name: occ,
                        type: 'scatter',
                        mode: 'lines',
                        stackgroup: 'one',
                        fillcolor: occupancyColors[index],
                        line: { color: occupancyColors[index], width: 0.5 },
                        hovertemplate: `%{fullData.name}<br>Year: %{x}<br>Count: %{y:,}<extra></extra>`
                    });
                });
            }
            
            const layout = {
                title: {
                    text: `Post-1940 Annual Building Construction (${buildingTypeFilter})${normalize ? ' - Normalized 100%' : ''}`,
                    font: { size: 20, color: '#333' }
                },
                xaxis: { 
                    title: 'Year',
                    dtick: 10,
                    tickangle: -45
                },
                yaxis: { 
                    title: normalize ? 'Percentage (%)' : 'Number of Buildings',
                    range: normalize ? [0, 100] : undefined
                },
                height: 500,
                hovermode: 'x unified',
                showlegend: true,
                legend: {
                    orientation: 'v',
                    yanchor: 'middle',
                    y: 0.5,
                    xanchor: 'left',
                    x: 1.02
                }
            };
            
            Plotly.newPlot('post1940Chart', traces, layout, {responsive: true});
            
            const areaTraces = [];
            
            if (normalize) {
                Array.from(occupancyTypes).forEach((occ, index) => {
                    const yValues = years.map(year => annualAreaData[year][occ] || 0);
                    
                    areaTraces.push({
                        x: years,
                        y: yValues,
                        name: occ,
                        type: 'scatter',
                        mode: 'lines',
                        stackgroup: 'one',
                        groupnorm: 'percent',
                        fillcolor: occupancyColors[index],
                        line: { color: occupancyColors[index], width: 0.5 },
                        hovertemplate: `%{fullData.name}<br>Year: %{x}<br>Percentage: %{y:.1f}%<extra></extra>`
                    });
                });
            } else {
                Array.from(occupancyTypes).forEach((occ, index) => {
                    const yValues = years.map(year => annualAreaData[year][occ] || 0);
                    
                    areaTraces.push({
                        x: years,
                        y: yValues,
                        name: occ,
                        type: 'scatter',
                        mode: 'lines',
                        stackgroup: 'one',
                        fillcolor: occupancyColors[index],
                        line: { color: occupancyColors[index], width: 0.5 },
                        hovertemplate: `%{fullData.name}<br>Year: %{x}<br>Area: %{y:,.0f} sqm<extra></extra>`
                    });
                });
            }
            
            const areaLayout = {
                title: {
                    text: `Post-1940 Total Est GFA sqmeters (${buildingTypeFilter})${normalize ? ' - Normalized 100%' : ''}`,
                    font: { size: 20, color: '#333' }
                },
                xaxis: { 
                    title: 'Year',
                    dtick: 10,
                    tickangle: -45
                },
                yaxis: { 
                    title: normalize ? 'Percentage (%)' : 'Total Est GFA sqmeters',
                    range: normalize ? [0, 100] : undefined
                },
                height: 500,
                hovermode: 'x unified',
                showlegend: true,
                legend: {
                    orientation: 'v',
                    yanchor: 'middle',
                    y: 0.5,
                    xanchor: 'left',
                    x: 1.02
                }
            };
            
            Plotly.newPlot('post1940AreaChart', areaTraces, areaLayout, {responsive: true});
            
            const decadeData = {};
            const post1940 = buildingData.post1940;
            
            Object.keys(post1940).forEach(decade => {
                decadeData[decade] = post1940[decade].total || 0;
            });
            
            const decades = Object.keys(decadeData).sort();
            const decadeColors = getPlasmaColors(decades.length);
            
            const comparisonData = [{
                x: decades,
                y: decades.map(d => decadeData[d]),
                type: 'bar',
                marker: { 
                    color: decadeColors,
                    line: {
                        color: 'white',
                        width: 1
                    }
                },
                hovertemplate: 'Decade: %{x}<br>Buildings Constructed: %{y:,}<extra></extra>'
            }];
            
            const comparisonLayout = {
                title: {
                    text: 'Buildings Constructed by Decade',
                    font: { size: 20, color: '#333' }
                },
                xaxis: { title: 'Decade' },
                yaxis: { title: 'Number of Buildings Constructed in Decade' },
                height: 400,
                showlegend: false
            };
            
            Plotly.newPlot('decadeComparisonChart', comparisonData, comparisonLayout, {responsive: true});
        }


        function updateOccupancyClustering() {
            if (!buildingData) return;
            
            const selectedClass = document.getElementById('occupancyClass').value;
            const kValue = parseInt(document.getElementById('occupancyK').value);
            const sampleSize = parseInt(document.getElementById('sampleSize').value);
            const sampleType = document.getElementById('sampleType').value;
            const useLogScale = document.getElementById('logScale').checked;
            const includeMaterial = document.getElementById('includeMaterial').checked;
            const includeFoundation = document.getElementById('includeFoundation').checked;
            const materialFilter = includeMaterial ? document.getElementById('materialTypeFilter').value : 'all';
            const foundationFilter = includeFoundation ? document.getElementById('foundationTypeFilter').value : 'all';
            
            // Determine feature combination
            let featureCombo = 'base';
            if (includeMaterial && includeFoundation) {
                featureCombo = 'both';
            } else if (includeMaterial) {
                featureCombo = 'material';
            } else if (includeFoundation) {
                featureCombo = 'foundation';
            }
            
            // Update dimension indicator
            let dimensions = ['Year', 'Footprint Area', 'Height', 'Occupancy'];
            let dimensionCount = 4;
            if (includeMaterial) {
                dimensions.push('Material');
                dimensionCount++;
            }
            if (includeFoundation) {
                dimensions.push('Foundation');
                dimensionCount++;
            }
            document.getElementById('activeDimensions').textContent = `${dimensions.join(', ')} (${dimensionCount}D)`;
            
            // Update clustering status
            const statusText = `Using pre-computed ${featureCombo} clustering (${dimensionCount}D)`;
            document.getElementById('clusteringStatusText').textContent = statusText;
            
            // Update filter status
            let filters = [];
            if (includeMaterial && materialFilter !== 'all') {
                filters.push(`Material: ${materialTypeMap[materialFilter] || materialFilter}`);
            }
            if (includeFoundation && foundationFilter !== 'all') {
                filters.push(`Foundation: ${foundationTypeMap[foundationFilter] || foundationFilter}`);
            }
            
            if (filters.length > 0) {
                document.getElementById('filterStatus').style.display = 'block';
                document.getElementById('activeFilters').textContent = filters.join(', ');
            } else {
                document.getElementById('filterStatus').style.display = 'none';
            }
            
            // Update sample type indicator
            const currentSampleTypeEl = document.getElementById('currentSampleType');
            const sampleDescriptionEl = document.getElementById('sampleDescription');
            
            if (sampleType === 'random') {
                currentSampleTypeEl.textContent = 'Random Sample';
                currentSampleTypeEl.style.color = '#fb9f3a';
                sampleDescriptionEl.textContent = 'Shows true data distribution - rare classes may have few or no points visible';
            } else {
                currentSampleTypeEl.textContent = 'Balanced Sample';
                currentSampleTypeEl.style.color = '#7201a8';
                sampleDescriptionEl.textContent = 'Shows equal representation of all occupancy classes for better pattern visibility';
            }
            
            // Choose sample type
            let allVizSamples;
            if (sampleType === 'random') {
                allVizSamples = [...buildingData.building_samples_random];
            } else {
                allVizSamples = [...buildingData.building_samples_balanced];
            }
            
            // Filter by selected occupancy class
            let samplesForViz = allVizSamples;
            if (selectedClass !== 'all') {
                samplesForViz = samplesForViz.filter(s => s.OCC_CLS === selectedClass);
            }
            
            // Apply material/foundation filters if specified
            if (includeMaterial && materialFilter !== 'all') {
                samplesForViz = samplesForViz.filter(s => s.material_type === materialFilter);
            }
            if (includeFoundation && foundationFilter !== 'all') {
                samplesForViz = samplesForViz.filter(s => s.foundation_type === foundationFilter);
            }
            
            // Sample down to user-selected size if needed
            if (samplesForViz.length > sampleSize) {
                samplesForViz = samplesForViz.sort(() => 0.5 - Math.random()).slice(0, sampleSize);
            }
            
            // Get appropriate cluster assignment based on feature combination
            const clusterKey = `cluster_${featureCombo}_k${kValue}`;
            samplesForViz.forEach(s => {
                s.displayCluster = s[clusterKey] !== undefined ? s[clusterKey] : null; // 如果没数据，则设为null
            });

            // Create 3D scatter plot
            // index.html L:1976
            // Create 3D scatter plot
            // MODIFICATION: The scatter plot now visualizes Footprint Area (x), Height (y), and Year (z), with points colored by cluster.
            const scatterData = [{
                x: samplesForViz.map(s => useLogScale ? Math.log10(s.SQMETERS + 1) : s.SQMETERS),
                y: samplesForViz.map(s => s.PRED_HEIGHT),
                z: samplesForViz.map(s => s.year_built < 1940 ? 1939 : s.year_built),
                mode: 'markers',
                type: 'scatter3d',
                marker: {
                    color: samplesForViz.map(s => s.displayCluster), // Color by the assigned cluster
                    colorscale: 'Plasma',
                    size: 5,
                    opacity: 0.7,
                    showscale: true,
                    colorbar: { 
                        title: 'Cluster', 
                        thickness: 20,
                        x: 1.02
                    },
                    cmin: 0,
                    cmax: kValue - 1
                },
                text: samplesForViz.map(s => {
                    let text = `${s.OCC_CLS}<br>Cluster: ${s.displayCluster !== null ? s.displayCluster + 1 : 'N/A'}`;
                    if (includeMaterial && s.material_type) {
                        text += `<br>Material: ${materialTypeMap[s.material_type] || s.material_type}`;
                    }
                    if (includeFoundation && s.foundation_type) {
                        text += `<br>Foundation: ${foundationTypeMap[s.foundation_type] || s.foundation_type}`;
                    }
                    return text;
                }),
                hovertemplate: 'Footprint: %{x:.1f} sqm' + (useLogScale ? ' (log)' : '') +
                              '<br>Height: %{y:.1f} m' +
                              '<br>Year: %{z}' +
                              '<br>%{text}<extra></extra>'
            }];
            
            const scatterLayout = {
                title: {
                    text: `${dimensionCount}D Clustering Visualization (K=${kValue}, ${samplesForViz.length} buildings${filters.length > 0 ? ' - Filtered' : ''})`,
                    font: { size: 20, color: '#333' }
                },
                scene: {
                    xaxis: { 
                        title: useLogScale ? 'Footprint Area (SQMETERS, log scale)' : 'Footprint Area (SQMETERS)'
                    },
                    yaxis: { 
                        title: 'Predicted Height (m)'
                    },
                    zaxis: { 
                        title: 'Year Built',
                        tickvals: [1939, 1950, 1970, 1990, 2010, 2020],
                        ticktext: ['pre-1940', '1950', '1970', '1990', '2010', '2020']
                    },
                    camera: {
                        eye: {x: 1.5, y: 1.5, z: 1.5}
                    }
                },
                height: 600,
                margin: {
                    l: 0,
                    r: 0,
                    b: 0,
                    t: 60
                }
            };
            
            Plotly.newPlot('occupancyClusterChart', scatterData, scatterLayout, {responsive: true});

            // Get pre-computed clustering results from enhanced data
            let fullStatsData = null;
            
            if (buildingData.occupancy_clusters_enhanced && 
                buildingData.occupancy_clusters_enhanced[selectedClass] &&
                buildingData.occupancy_clusters_enhanced[selectedClass].feature_combinations &&
                buildingData.occupancy_clusters_enhanced[selectedClass].feature_combinations[featureCombo]) {
                
                fullStatsData = buildingData.occupancy_clusters_enhanced[selectedClass];
                const kStats = fullStatsData.feature_combinations[featureCombo][kValue];
                
                if (kStats && kStats.clusters) {
                    // Create full dataset table with enhanced clustering
                    let tableHeaders = ['Cluster', 'Total Count', 'Avg Footprint (m²)', 'Avg Height (m)', 'Avg Year'];
                    let tableValues = [
                        kStats.clusters.map(s => `Cluster ${s.cluster_id + 1}`),
                        kStats.clusters.map(s => s.count.toLocaleString()),
                        kStats.clusters.map(s => Math.round(s.avg_sqmeters)),
                        kStats.clusters.map(s => s.avg_height.toFixed(1)),
                        kStats.clusters.map(s => Math.round(s.avg_year))
                    ];
                    
                    // Add material/foundation columns if present
                    if (featureCombo === 'material' || featureCombo === 'both') {
                        tableHeaders.push('Dom. Material');
                        tableValues.push(kStats.clusters.map(s => 
                            s.dominant_material ? (materialTypeMap[s.dominant_material] || s.dominant_material) : '-'
                        ));
                    }
                    if (featureCombo === 'foundation' || featureCombo === 'both') {
                        tableHeaders.push('Dom. Foundation');
                        tableValues.push(kStats.clusters.map(s => 
                            s.dominant_foundation ? (foundationTypeMap[s.dominant_foundation] || s.dominant_foundation) : '-'
                        ));
                    }
                    
                    const fullTableData = [{
                        type: 'table',
                        header: {
                            values: tableHeaders,
                            align: 'center',
                            line: {width: 1, color: '#dee2e6'},
                            fill: {color: '#bd3786'},
                            font: {family: "Arial", size: 14, color: "white"}
                        },
                        cells: {
                            values: tableValues,
                            align: 'center',
                            line: {color: "#dee2e6", width: 1},
                            fill: {color: ['#f8f9fa', 'white']},
                            font: {family: "Arial", size: 12, color: ["#333"]}
                        }
                    }];
                    
                    let displayTitle = '';
                    const totalBuildings = fullStatsData.total_buildings;

                    const formatNumber = (num) => {
                        if (num >= 1000000) {
                            return `${(num / 1000000).toFixed(2)}M`;
                        } else if (num >= 1000) {
                            return `${(num / 1000).toFixed(1)}K`;
                        }
                        return num.toString();
                    };

                    if (selectedClass === 'all') {
                        displayTitle = `Complete Dataset Statistics - All Buildings (${formatNumber(totalBuildings)} total)`;
                    } else {
                        displayTitle = `Complete Dataset Statistics - ${selectedClass} (${formatNumber(totalBuildings)} buildings)`;
                    }

                    displayTitle += ` (K=${kValue})`;

                    const fullTableLayout = {
                        title: {
                            text: displayTitle,
                            font: { size: 18, color: '#333' }
                        },
                        height: 350
                    };
                    
                    Plotly.newPlot('occupancyFullStatsChart', fullTableData, fullTableLayout, {responsive: true});
                    
                    // Create elbow chart
                    const elbowX = Object.keys(fullStatsData.feature_combinations[featureCombo]).map(k => parseInt(k));
                    const elbowY = elbowX.map(k => fullStatsData.feature_combinations[featureCombo][k].wcss);

                    const elbowData = [{
                        x: elbowX,
                        y: elbowY,
                        mode: 'lines+markers',
                        type: 'scatter',
                        marker: { 
                            size: 10, 
                            color: '#bd3786',
                            line: { color: 'white', width: 2 }
                        },
                        line: { width: 3, color: '#bd3786' }
                    }];
                    
                    if (elbowX.includes(kValue)) {
                        const idx = elbowX.indexOf(kValue);
                        elbowData.push({
                            x: [kValue],
                            y: [elbowY[idx]],
                            mode: 'markers',
                            type: 'scatter',
                            marker: {
                                size: 15,
                                color: '#f0f921',
                                line: { color: '#bd3786', width: 2 }
                            },
                            showlegend: false,
                            hovertemplate: 'Current K=%{x}<br>WCSS=%{y:.0f}<extra></extra>'
                        });
                    }
                    
                    const elbowLayout = {
                        title: {
                            text: `Elbow Method - ${selectedClass} (${dimensionCount}D ${featureCombo}, Current K=${kValue})`,
                            font: { size: 18, color: '#333' }
                        },
                        xaxis: { title: 'Number of Clusters (K)', dtick: 1 },
                        yaxis: { title: 'WCSS' },
                        height: 350,
                        showlegend: false
                    };
                    
                    Plotly.newPlot('occupancyElbowChart', elbowData, elbowLayout, {responsive: true});
                }
            }
            
            // Sample statistics table
            const sampleStats = {};
            for (let i = 0; i < kValue; i++) {
                sampleStats[i] = { 
                    count: 0, 
                    sqmetersSum: 0,
                    heightSum: 0, 
                    yearSum: 0, 
                    materials: {},
                    foundations: {}
                };
            }
            
            samplesForViz.forEach(s => {
                const cluster = s.displayCluster;

                if (cluster !== null && cluster !== undefined) {
                    sampleStats[cluster].count++;
                    sampleStats[cluster].sqmetersSum += s.SQMETERS;
                    sampleStats[cluster].heightSum += s.PRED_HEIGHT;
                    sampleStats[cluster].yearSum += s.year_built;

                    // Track material and foundation types
                    if (s.material_type) {
                        if (!sampleStats[cluster].materials[s.material_type]) {
                            sampleStats[cluster].materials[s.material_type] = 0;
                        }
                        sampleStats[cluster].materials[s.material_type]++;
                    }
                    if (s.foundation_type) {
                        if (!sampleStats[cluster].foundations[s.foundation_type]) {
                            sampleStats[cluster].foundations[s.foundation_type] = 0;
                        }
                        sampleStats[cluster].foundations[s.foundation_type]++;
                    }
                }
            });

            const headerColor = sampleType === 'random' ? '#fb9f3a' : '#7201a8';
            
            // MODIFICATION: Updated table headers and values for the sample statistics.
            let sampleTableHeaders = ['Cluster', 'Sample Count', 'Avg Footprint (m²)', 'Avg Height (m)', 'Avg Year'];
            let sampleTableValues = [
                Object.keys(sampleStats).map(c => `Cluster ${parseInt(c) + 1}`),
                Object.values(sampleStats).map(s => s.count.toLocaleString()),
                Object.values(sampleStats).map(s => s.count > 0 ? Math.round(s.sqmetersSum / s.count) : 0),
                Object.values(sampleStats).map(s => s.count > 0 ? (s.heightSum / s.count).toFixed(1) : 0),
                Object.values(sampleStats).map(s => s.count > 0 ? Math.round(s.yearSum / s.count) : 0)
            ];
            
            // Add material/foundation columns if in feature combo
            if (featureCombo === 'material' || featureCombo === 'both') {
                sampleTableHeaders.push('Dom. Material');
                sampleTableValues.push(Object.values(sampleStats).map(s => {
                    const mats = Object.entries(s.materials).sort((a, b) => b[1] - a[1]);
                    return mats.length > 0 ? (materialTypeMap[mats[0][0]] || mats[0][0]) : '-';
                }));
            }
            if (featureCombo === 'foundation' || featureCombo === 'both') {
                sampleTableHeaders.push('Dom. Foundation');
                sampleTableValues.push(Object.values(sampleStats).map(s => {
                    const founds = Object.entries(s.foundations).sort((a, b) => b[1] - a[1]);
                    return founds.length > 0 ? (foundationTypeMap[founds[0][0]] || founds[0][0]) : '-';
                }));
            }
            
            const sampleTableData = [{
                type: 'table',
                header: {
                    values: sampleTableHeaders,
                    align: 'center',
                    line: {width: 1, color: '#dee2e6'},
                    fill: {color: headerColor},
                    font: {family: "Arial", size: 14, color: "white"}
                },
                cells: {
                    values: sampleTableValues,
                    align: 'center',
                    line: {color: "#dee2e6", width: 1},
                    fill: {color: ['#f8f9fa', 'white']},
                    font: {family: "Arial", size: 12, color: ["#333"]}
                }
            }];
            
            const sampleTableLayout = {
                title: {
                    text: `Sample Statistics (K=${kValue}, ${samplesForViz.length} buildings)`,
                    font: { size: 18, color: '#333' }
                },
                height: 350
            };
            
            Plotly.newPlot('occupancySampleStatsChart', sampleTableData, sampleTableLayout, {responsive: true});
        }

        function showHeatmap(type) {
            currentHeatmapType = type;
            
            document.getElementById('countHeatmapTab').classList.toggle('active', type === 'count');
            document.getElementById('areaHeatmapTab').classList.toggle('active', type === 'area');
            
            document.getElementById('countHeatmapContainer').style.display = type === 'count' ? 'block' : 'none';
            document.getElementById('areaHeatmapContainer').style.display = type === 'area' ? 'block' : 'none';
            
            if (type === 'area') {
                updateAreaHeatmap();
            }
        }
        
        function updateMaterialsHeatmap() {
            if (!buildingData || !buildingData.materials_foundation) return;
            
            const filter = document.getElementById('materialFilter').value;
            const useLogScale = document.getElementById('heatmapLogScale').checked;
            const data = buildingData.materials_foundation[filter] || buildingData.materials_foundation.all;
            
            window.currentMaterialsData = data;
            
            const materialNames = data.materials.map(m => materialTypeMap[m] || m);
            const foundationNames = data.foundations.map(f => foundationTypeMap[f] || f);
            
            updateHeatmapChart(data, materialNames, foundationNames, filter, useLogScale, 'count');
            
            if (currentHeatmapType === 'area') {
                updateAreaHeatmap();
            }
            
            createMaterialTrendsChart(materialNames);
        }
        
        function updateHeatmapOnly() {
            if (!buildingData || !buildingData.materials_foundation) return;
            
            const filter = document.getElementById('materialFilter').value;
            const useLogScale = document.getElementById('heatmapLogScale').checked;
            const data = buildingData.materials_foundation[filter] || buildingData.materials_foundation.all;
            
            const materialNames = data.materials.map(m => materialTypeMap[m] || m);
            const foundationNames = data.foundations.map(f => foundationTypeMap[f] || f);
            
            if (currentHeatmapType === 'count') {
                updateHeatmapChart(data, materialNames, foundationNames, filter, useLogScale, 'count');
            } else {
                updateAreaHeatmap();
            }
        }
        
        function updateHeatmapChart(data, materialNames, foundationNames, filter, useLogScale, type) {
            const isArea = type === 'area';
            const matrix = isArea ? (data.area_matrix || data.matrix) : data.matrix;
            
            let zValues = matrix;
            if (useLogScale) {
                zValues = matrix.map(row => 
                    row.map(val => val > 0 ? Math.log10(val + 1) : 0)
                );
            }
            
            const heatmapData = [{
                z: zValues,
                x: foundationNames,
                y: materialNames,
                type: 'heatmap',
                colorscale: 'Plasma',
                showscale: true,
                text: matrix.map(row => row.map(val => {
                    if (isArea) {
                        return val >= 1000000 ? `${(val/1000000).toFixed(1)}M sqm` :
                               val >= 1000 ? `${(val/1000).toFixed(1)}K sqm` :
                               `${val.toFixed(0)} sqm`;
                    } else {
                        return val.toLocaleString();
                    }
                })),
                texttemplate: '%{text}',
                textfont: {
                    size: 10,
                    color: 'white'
                },
                hovertemplate: `Material: %{y}<br>Foundation: %{x}<br>${isArea ? 'Total Area' : 'Count'}: %{text}<br><b>Click to see occupancy breakdown</b><extra></extra>`,
                colorbar: {
                    title: useLogScale ? `Log(${isArea ? 'Area' : 'Count'})` : (isArea ? 'Total Area (sqm)' : 'Count')
                }
            }];
            
            const heatmapLayout = {
                title: {
                    text: `Building ${isArea ? 'Total Est GFA' : 'Count'} - Materials vs Foundation Types ${filter !== 'all' ? '(' + filter + ')' : ''} ${useLogScale ? '(Log Scale)' : ''}`,
                    font: { size: 18, color: '#333' }
                },
                xaxis: { 
                    title: 'Foundation Type',
                    tickangle: -45,
                    tickfont: { size: 11 }
                },
                yaxis: { 
                    title: 'Material Type',
                    tickfont: { size: 11 }
                },
                height: 550,
                margin: {
                    l: 100,
                    r: 50,
                    t: 100,
                    b: 120
                }
            };
            
            const elementId = isArea ? 'materialsAreaHeatmap' : 'materialsHeatmap';
            Plotly.newPlot(elementId, heatmapData, heatmapLayout, {responsive: true});
            
            var heatmapElement = document.getElementById(elementId);
            heatmapElement.on('plotly_click', function(eventData) {
                if (!eventData || !eventData.points || eventData.points.length === 0) {
                    return;
                }
                
                const point = eventData.points[0];
                const materialIdx = point.pointIndex[0];
                const foundationIdx = point.pointIndex[1];
                
                const material = data.materials[materialIdx];
                const foundation = data.foundations[foundationIdx];
                const value = matrix[materialIdx][foundationIdx];
                
                showOccupancyBreakdown(material, foundation, value, filter, isArea);
            });
        }
        
        function updateAreaHeatmap() {
            if (!buildingData || !buildingData.materials_foundation) return;
            
            const filter = document.getElementById('materialFilter').value;
            const useLogScale = document.getElementById('heatmapLogScale').checked;
            const data = buildingData.materials_foundation[filter] || buildingData.materials_foundation.all;
            
            const materialNames = data.materials.map(m => materialTypeMap[m] || m);
            const foundationNames = data.foundations.map(f => foundationTypeMap[f] || f);
            
            updateHeatmapChart(data, materialNames, foundationNames, filter, useLogScale, 'area');
        }
        
        function createMaterialTrendsChart() {
            if (!buildingData || !buildingData.building_samples_random) {
                document.getElementById('materialsTrendChart').innerHTML = '<p>Trend data not available.</p>';
                return;
            }

            const normalizeBy = document.getElementById('materialTrendNormalizeBy')?.value || 'count';

            let trendData = buildingData.building_samples_random.filter(d =>
                d.year_built && d.year_built >= 1940 && d.material_type && d['Est GFA sqmeters']
            );

            const yearData = {};
            const materialTypes = new Set();
            trendData.forEach(d => {
                const year = d.year_built;
                if (!yearData[year]) yearData[year] = {};
                if (!yearData[year][d.material_type]) yearData[year][d.material_type] = { count: 0, gfa: 0 };
                yearData[year][d.material_type].count++;
                yearData[year][d.material_type].gfa += d['Est GFA sqmeters'];
                materialTypes.add(d.material_type);
            });

            const sortedYears = Object.keys(yearData).sort((a, b) => a - b);
            const sortedMaterials = Array.from(materialTypes).sort();
            const materialColors = getPlasmaColors(sortedMaterials.length);

            const traces = sortedMaterials.map((mat, index) => {
                const yValues = sortedYears.map(year => {
                    if (yearData[year][mat]) {
                        return normalizeBy === 'gfa' ? yearData[year][mat].gfa : yearData[year][mat].count;
                    }
                    return 0;
                });
                return {
                    x: sortedYears.map(y => parseInt(y)),
                    y: yValues,
                    name: materialTypeMap[mat] || mat,
                    type: 'scatter',
                    mode: 'lines',
                    stackgroup: 'one',
                    groupnorm: 'percent',
                    fillcolor: materialColors[index],
                    line: { color: materialColors[index], width: 0.5 },
                    hovertemplate: `<b>${materialTypeMap[mat] || mat}</b><br>Year: %{x}<br>Percentage: %{y:.2f}%<extra></extra>`
                };
            });
            
            const layout = {
                title: { text: `Material Usage Trends by Year (Normalized by ${normalizeBy === 'gfa' ? 'GFA' : 'Count'})`, font: { size: 18, color: '#333' } },
                xaxis: { title: 'Year', type: 'linear', dtick: 10, tickangle: -45, range: [1940, Math.max(...sortedYears.map(y => parseInt(y))) + 1] },
                yaxis: { title: 'Percentage of New Construction (%)', ticksuffix: '%', range: [0, 100] },
                height: 500,
                hovermode: 'x unified',
                showlegend: true,
                legend: { orientation: 'v', yanchor: 'middle', y: 0.5, xanchor: 'left', x: 1.02 }
            };
            
            const chartDiv = document.getElementById('materialsTrendChart');
            Plotly.purge(chartDiv);
            Plotly.newPlot('materialsTrendChart', traces, layout, {responsive: true});
        }
        
        function showOccupancyBreakdown(material, foundation, totalValue, filter, isArea = false) {
            const data = buildingData.materials_foundation[filter] || buildingData.materials_foundation.all;
            const key = `${material}_${foundation}`;
            
            const breakdownData = data.occupancy_breakdown && data.occupancy_breakdown[key];
            
            if (!breakdownData) {
                console.warn(`No breakdown data for key: ${key}`);
                currentOccupancyData = {}; 
            } else {
                currentOccupancyData = isArea ? breakdownData.occupancy_areas : breakdownData.occupancy_counts;
            }
            
            currentMaterialSelection = {
                material: materialTypeMap[material] || material,
                foundation: foundationTypeMap[foundation] || foundation,
                totalValue: totalValue,
                filter: filter,
                isArea: isArea
            };
            
            document.getElementById('breakdownTitle').textContent = 
                `Occupancy Distribution: ${currentMaterialSelection.material} / ${currentMaterialSelection.foundation}`;
            
            let subtitle = isArea ? 
                `Total Est GFA: ${totalValue >= 1000000 ? (totalValue/1000000).toFixed(1) + 'M' : 
                                   totalValue >= 1000 ? (totalValue/1000).toFixed(1) + 'K' : 
                                   totalValue.toFixed(0)} sqm` :
                `Total Buildings: ${totalValue.toLocaleString()}`;
            subtitle += filter !== 'all' ? ' (' + filter + ')' : '';
            
            document.getElementById('breakdownSubtitle').textContent = subtitle;
            
            const container = document.getElementById('occupancyBreakdownContainer');
            container.style.display = 'block';
            container.style.opacity = '0';
            setTimeout(() => {
                container.style.transition = 'opacity 0.5s ease';
                container.style.opacity = '1';
            }, 10);
            
            updateOccupancyBreakdown();
            
            setTimeout(() => {
                container.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'center' 
                });
            }, 100);
        }
        
        function updateOccupancyBreakdown() {
            if (!currentOccupancyData) return;
            
            const chartType = document.getElementById('breakdownChartType').value;
            const isArea = currentMaterialSelection && currentMaterialSelection.isArea;
            
            const sortedData = Object.entries(currentOccupancyData)
                .sort((a, b) => b[1] - a[1]);
            
            const labels = sortedData.map(([k, v]) => k);
            const values = sortedData.map(([k, v]) => v);
            const percentages = values.map(v => (v / values.reduce((a, b) => a + b, 0) * 100).toFixed(1));
            
            let plotData, layout;
            
            if (chartType === 'pie') {
                const total = values.reduce((a, b) => a + b, 0);

                const textArray = labels.map((label, i) => {
                    const percentage = (values[i] / total * 100);
                    
                    if (percentage > 10) {
                        return `${label}<br>${percentage.toFixed(1)}%`;
                    } else if (percentage > 5) {
                        return `${percentage.toFixed(1)}%`;
                    } else if (percentage > 2) {
                        return `${percentage.toFixed(0)}%`;
                    } else {
                        return '';
                    }
                });
                
                plotData = [{
                    values: values,
                    labels: labels,
                    type: 'pie',
                    hole: 0.4,
                    marker: {
                        colors: getPlasmaColors(labels.length),
                        line: {
                            color: 'white',
                            width: 1
                        }
                    },
                    text: textArray,
                    textinfo: 'text',
                    textposition: 'auto',
                    textfont: {
                        size: 12,
                        color: 'white'
                    },
                    insidetextorientation: 'radial',
                    hovertemplate: `%{label}<br>${isArea ? 'Area' : 'Count'}: %{value:,}<br>Percentage: %{percent}<extra></extra>`,
                }];
                
                layout = {
                    title: {
                        text: `Occupancy Class Distribution ${isArea ? '(by Area)' : '(by Count)'}`,
                        font: { size: 18, color: '#333' }
                    },
                    height: 500,
                    showlegend: true,
                    legend: {
                        orientation: 'v',
                        yanchor: 'middle',
                        y: 0.5,
                        xanchor: 'left',
                        x: 1.02
                    }
                };
            } else if (chartType === 'bar') {
                plotData = [{
                    x: labels,
                    y: values,
                    type: 'bar',
                    marker: {
                        color: getPlasmaColors(labels.length),
                        line: {
                            color: 'white',
                            width: 1
                        }
                    },
                    text: percentages.map(p => `${p}%`),
                    textposition: 'outside',
                    hovertemplate: `%{x}<br>${isArea ? 'Area' : 'Count'}: %{y:,}<br>%{text}<extra></extra>`
                }];
                
                layout = {
                    title: {
                        text: `Occupancy Class Distribution ${isArea ? '(by Area)' : '(by Count)'}`,
                        font: { size: 18, color: '#333' }
                    },
                    xaxis: { 
                        title: 'Occupancy Class',
                        tickangle: -45
                    },
                    yaxis: { 
                        title: isArea ? 'Total Est GFA (sqm)' : 'Number of Buildings'
                    },
                    height: 500,
                    showlegend: false
                };
            } else {
                plotData = [{
                    x: values,
                    y: labels,
                    type: 'bar',
                    orientation: 'h',
                    marker: {
                        color: getPlasmaColors(labels.length),
                        line: {
                            color: 'white',
                            width: 1
                        }
                    },
                    text: values.map((v, i) => {
                        if (isArea) {
                            const formatted = v >= 1000000 ? `${(v/1000000).toFixed(1)}M sqm` :
                                            v >= 1000 ? `${(v/1000).toFixed(1)}K sqm` :
                                            `${v.toFixed(0)} sqm`;
                            return `${formatted} (${percentages[i]}%)`;
                        } else {
                            return `${v.toLocaleString()} (${percentages[i]}%)`;
                        }
                    }),
                    textposition: 'outside',
                    hovertemplate: `%{y}<br>${isArea ? 'Area' : 'Count'}: %{x:,}<br>%{text}<extra></extra>`
                }];
                
                layout = {
                    title: {
                        text: `Occupancy Class Distribution ${isArea ? '(by Area)' : '(by Count)'}`,
                        font: { size: 18, color: '#333' }
                    },
                    xaxis: { 
                        title: isArea ? 'Total Est GFA (sqm)' : 'Number of Buildings'
                    },
                    yaxis: { 
                        title: 'Occupancy Class'
                    },
                    height: Math.max(400, labels.length * 40),
                    margin: {
                        l: 150
                    },
                    showlegend: false
                };
            }
            
            Plotly.newPlot('occupancyBreakdownChart', plotData, layout, {responsive: true});
        }


    function updateInteractiveExplorer() {
            if (!buildingData) return;
            
            const vizType = document.getElementById('vizType').value;
            const yearStart = parseInt(document.getElementById('yearStart').value);
            const yearEnd = parseInt(document.getElementById('yearEnd').value);
            const areaMin = parseInt(document.getElementById('areaMin').value);
            const areaMax = parseInt(document.getElementById('areaMax').value);
            
            const filteredData = buildingData.building_samples_random.filter(d => 
                d.year_built >= yearStart && d.year_built <= yearEnd &&
                d['Est GFA sqmeters'] >= areaMin && 
                d['Est GFA sqmeters'] <= areaMax
            );
            
            let plotData, layout;
            
            switch(vizType) {
                case 'scatter3d':
                    plotData = [{
                        x: filteredData.map(d => d.year_built < 1940 ? 1939 : d.year_built),
                        y: filteredData.map(d => d['Est GFA sqmeters']),
                        z: filteredData.map(d => d.cluster),
                        mode: 'markers',
                        type: 'scatter3d',
                        marker: {
                            size: 5,
                            color: filteredData.map(d => d.cluster),
                            colorscale: 'Plasma',
                            showscale: true
                        },
                        text: filteredData.map(d => d.OCC_CLS),
                        hovertemplate: 'Year: %{x}<br>Est GFA: %{y:.1f} sqm<br>Cluster: %{z}<br>Type: %{text}<extra></extra>'
                    }];
                    layout = {
                        title: '3D Building Data Visualization',
                        scene: {
                            xaxis: { title: 'Year Built' },
                            yaxis: { title: 'Est GFA (sqm)' },
                            zaxis: { title: 'Cluster' }
                        },
                        height: 600
                    };
                    break;
                case 'sunburst':
                    // ... (Sunburst logic is correct and does not use GFA directly)
                    const sunburstLabels = ['Buildings'];
                    const sunburstParents = [''];
                    const sunburstValues = [filteredData.length];
                    const occupancyGroups = {};
                    filteredData.forEach(d => {
                        if (!occupancyGroups[d.OCC_CLS]) occupancyGroups[d.OCC_CLS] = {};
                        const decade = d.year_built < 1940 ? 'pre-1940' : `${Math.floor(d.year_built / 10) * 10}s`;
                        if (!occupancyGroups[d.OCC_CLS][decade]) occupancyGroups[d.OCC_CLS][decade] = 0;
                        occupancyGroups[d.OCC_CLS][decade]++;
                    });
                    Object.keys(occupancyGroups).forEach(occ => {
                        sunburstLabels.push(occ);
                        sunburstParents.push('Buildings');
                        sunburstValues.push(Object.values(occupancyGroups[occ]).reduce((a, b) => a + b, 0));
                        Object.keys(occupancyGroups[occ]).forEach(decade => {
                            sunburstLabels.push(`${occ} - ${decade}`);
                            sunburstParents.push(occ);
                            sunburstValues.push(occupancyGroups[occ][decade]);
                        });
                    });
                    plotData = [{
                        type: 'sunburst',
                        labels: sunburstLabels,
                        parents: sunburstParents,
                        values: sunburstValues,
                        branchvalues: 'total',
                        marker: { colorscale: 'Plasma' }
                    }];
                    layout = { title: 'Hierarchical Building Distribution', height: 600 };
                    break;
                case 'parallel':
                    plotData = [{
                        type: 'parcoords',
                        dimensions: [
                            { label: 'Year', values: filteredData.map(d => d.year_built), range: [yearStart, yearEnd] },
                            { label: 'Est GFA', values: filteredData.map(d => d['Est GFA sqmeters']), range: [areaMin, areaMax] },
                            { label: 'Cluster', values: filteredData.map(d => d.cluster), range: [0, 6] }
                        ],
                        line: { color: filteredData.map(d => d.cluster), colorscale: 'Plasma', showscale: true }
                    }];
                    layout = { title: 'Parallel Coordinates - Building Attributes', height: 600 };
                    break;
                case 'box':
                    const occupancies = [...new Set(filteredData.map(d => d.OCC_CLS))];
                    plotData = occupancies.map((occ, i) => ({
                        y: filteredData.filter(d => d.OCC_CLS === occ).map(d => d['Est GFA sqmeters']),
                        type: 'box',
                        name: occ,
                        boxpoints: 'outliers',
                        marker: { color: plasmaColors[i % plasmaColors.length] }
                    }));
                    layout = { title: 'Est GFA Distribution by Occupancy Class', yaxis: { title: 'Est GFA (sqm)' }, height: 500 };
                    break;
                case 'violin':
                    const violinOccupancies = [...new Set(filteredData.map(d => d.OCC_CLS))];
                    plotData = violinOccupancies.map((occ, index) => ({
                        y: filteredData.filter(d => d.OCC_CLS === occ).map(d => d['Est GFA sqmeters']),
                        type: 'violin',
                        name: occ,
                        box: { visible: true },
                        meanline: { visible: true },
                        fillcolor: plasmaColors[index % plasmaColors.length],
                        opacity: 0.6
                    }));
                    layout = { title: 'Est GFA Distribution (Violin Plot)', yaxis: { title: 'Est GFA (sqm)' }, height: 500 };
                    break;
                case 'treemap':
                    const treemapLabels = ['Root'];
                    const treemapParents = [''];
                    const treemapValues = [0];
                    const treemapData = {};
                    filteredData.forEach(d => {
                        if (!treemapData[d.OCC_CLS]) treemapData[d.OCC_CLS] = 0;
                        treemapData[d.OCC_CLS]++;
                    });
                    Object.entries(treemapData).forEach(([occ, count]) => {
                        treemapLabels.push(occ);
                        treemapParents.push('Root');
                        treemapValues.push(count);
                    });
                    plotData = [{
                        type: 'treemap',
                        labels: treemapLabels,
                        parents: treemapParents,
                        values: treemapValues,
                        textinfo: "label+value+percent root",
                        marker: { colorscale: 'Plasma' }
                    }];
                    layout = { title: 'Building Distribution Treemap', height: 600 };
                    break;
            }
            Plotly.newPlot('interactiveChart', plotData, layout, {responsive: true});
        }
        
        function exportChart(chartId, filename) {
            Plotly.downloadImage(chartId, {
                format: 'png',
                width: 1200,
                height: 800,
                filename: filename || 'chart'
            });
        }
        
        function exportAllData() {
            if (!buildingData) {
                alert('No data available to export');
                return;
            }
            
            const dataStr = JSON.stringify(buildingData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'building_analysis_data.json';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function createMixScPieChart() {
            if (!buildingData || !buildingData.mix_sc_distribution) {
                document.getElementById('mixScPieChart').innerHTML = '<p>MIX_SC distribution data not available.</p>';
                return;
            }

            const includeSameType = document.getElementById('toggleSameType').checked;
            let fullData = { ...buildingData.mix_sc_distribution };

            let labels = Object.keys(fullData);
            let values = Object.values(fullData);

            if (!includeSameType) {
                const sameTypeIndex = labels.indexOf('Same Type Only');
                if (sameTypeIndex > -1) {
                    labels.splice(sameTypeIndex, 1);
                    values.splice(sameTypeIndex, 1);
                }
            }

            if (labels.length === 0) {
                document.getElementById('mixScPieChart').innerHTML = '<p>No data to display for the current selection.</p>';
                return;
            }
            
            // Assign specific, consistent colors for better readability
            const colorMap = {
                'Same Type Only': '#2E7D32', // Green for homogeneity
                'Same & Different Types (MIX_SC2)': '#FDD835', // Yellow for some conflict
                '1 Conflict Type (MIX_SC1)': '#FF9800', // Orange for more conflict
                '>1 Conflict Types (MIX_SC3)': '#E53935' // Red for high conflict
            };
            const pieColors = labels.map(label => colorMap[label] || '#999');


            const pieData = [{
                values: values,
                labels: labels,
                type: 'pie',
                hole: 0.4,
                marker: {
                    colors: pieColors,
                    line: {
                        color: 'white',
                        width: 1
                    }
                },
                textinfo: 'percent',
                textposition: 'inside',
                insidetextorientation: 'radial',
                hovertemplate: '<b>%{label}</b><br>Building Count: %{value:,}<br>%{percent}<extra></extra>'
            }];

            const layout = {
                title: {
                    text: 'Building Homogeneity Distribution',
                    font: { size: 20, color: '#333' }
                },
                height: 500,
                showlegend: true,
                legend: {
                    orientation: 'v',
                    yanchor: 'middle',
                    y: 0.5,
                    xanchor: 'left',
                    x: 1.05
                }
            };

            Plotly.newPlot('mixScPieChart', pieData, layout, { responsive: true });
        }

        function getYearOccSankeyTitle() {
        const dims = ["Construction Year", "Occupancy"];
        if (document.getElementById("toggleMaterial")?.checked)   dims.push("Material");
        if (document.getElementById("toggleFoundation")?.checked) dims.push("Foundation");
        if (document.getElementById("toggleSoil")?.checked)       dims.push("Soil");
        return dims.join(" \u2192 "); 
        }


        function updateYearOccSankeyTitle() {
        const el = document.getElementById("yearOccSankeyTitle");
        if (el) el.textContent = getYearOccSankeyTitle();
        }


        function handleYearOccToggleChange() {
        updateYearOccSankeyTitle();
        if (typeof createYearOccSankey === "function") createYearOccSankey();
        }


        document.addEventListener("DOMContentLoaded", updateYearOccSankeyTitle);


        (function patchCreateYearOcc() {
        const orig = window.createYearOccSankey;
        if (typeof orig === "function") {
            window.createYearOccSankey = function() {
            const r = orig.apply(this, arguments);
            try { updateYearOccSankeyTitle(); } catch(e) {}
            return r;
            }
        }
        })();
                
        function _ts() {
            const d = new Date();
            const z = n => String(n).padStart(2, '0');
            return `${d.getFullYear()}${z(d.getMonth()+1)}${z(d.getDate())}_${z(d.getHours())}${z(d.getMinutes())}${z(d.getSeconds())}`;
        }

       
        async function downloadYearOccSankey() {
            const gd = document.getElementById('yearOccSankey'); 
            if (!gd) { alert('Plot not found'); return; }

        
            const format = document.getElementById('yearOccExportFormat')?.value || 'png';
            const scale  = parseInt(document.getElementById('yearOccExportScale')?.value || '3', 10);
            const transparent = !!document.getElementById('yearOccTransparentBg')?.checked;

          
            const rect   = gd.getBoundingClientRect();
            const width  = Math.max(800, Math.round(rect.width));
            const height = (gd._fullLayout && gd._fullLayout.height) ? gd._fullLayout.height
                        : Math.max(560, Math.round(rect.height) || 560);

          
            const prevPaper = (gd.layout && gd.layout.paper_bgcolor) ?? null;
            const prevPlot  = (gd.layout && gd.layout.plot_bgcolor)  ?? null;
            const paper = transparent ? 'rgba(0,0,0,0)' : 'white';
            const plot  = transparent ? 'rgba(0,0,0,0)' : 'white';

            try {
            await Plotly.relayout(gd, { 'paper_bgcolor': paper, 'plot_bgcolor': plot });

           
            const opts = {
                format,
                filename: `sankey_year_occ_${_ts()}`,
                width:  (format === 'svg') ? width  : width  * scale,
                height: (format === 'svg') ? height : height * scale,
                scale:  1 
            };

            await Plotly.downloadImage(gd, opts);
            } catch (err) {
            console.error(err);
            alert('Export failed. See console for details.');
            } finally {

            await Plotly.relayout(gd, { 'paper_bgcolor': prevPaper, 'plot_bgcolor': prevPlot });
            }
        }

    </script>
</body>
</html>